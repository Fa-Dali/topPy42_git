''' 9_0_magical_methods.py

**Что такое магические методы в Python**

Магические методы — это специальные методы классов в Python,
которые начинаются и заканчиваются двумя подчеркиваниями (`__method_name__`).
Они позволяют разработчикам переопределять поведение стандартных операций
и операторов. Например, используя магический метод `__add__`,
мы можем определить операцию сложения объектов класса.

Эти методы называются "магическими", потому что они автоматически
вызываются интерпретатором Python при выполнении определенных действий,
таких как создание экземпляра класса, доступ к атрибутам, арифметические
операции и другие.

## Полезность магических методов

Для начинающих программистов, особенно детей, магические методы помогают
сделать код более выразительным и удобным для чтения. Это похоже на волшебство!
Представьте себе возможность заставить объекты складывать себя друг с другом
простым знаком плюс (`+`), или сравнивать объекты простыми операторами
вроде `<` или `==`.

Например, если у вас есть класс, представляющий игрушечную машину,
вы можете научить её "гоняться" с другой машиной, просто добавив
знак больше (`>`), вот так:
'''
class ToyCar:
    def __init__(self, speed):
        self.speed = speed

    # Определяем оператор сравнения скорости машин
    def __gt__(self, other_car):
        return self.speed > other_car.speed

car1 = ToyCar(80)
car2 = ToyCar(70)

# Теперь машины сами знают, кто быстрее!
print(car1 > car2)  # True
'''
Это делает работу с объектами гораздо веселее и понятнее даже детям.

---

## **Полный список магических методов Python**

Вот подробный перечень всех основных магических методов, используемых 
в Python. Некоторые из них используются чаще, некоторые реже, но знание 
полного списка помогает лучше понимать возможности языка.

### Создание экземпляров и инициализация
- __new__(cls[, ...]): ...Создает новый экземпляр класса.
- __init__(self[, ...]): .Инициализирует объект после его создания.
- __del__(self): .........Метод, вызываемый перед уничтожением объекта.

### Управление доступом к атрибутам
- __getattr__(self, name): ........ Возвращает значение атрибута, если оно не 
                                        найдено обычным способом.                                       
- __setattr__(self, name, value): . Устанавливает значение атрибута.

- __delattr__(self, name): ........ Удаляет атрибут.

- __getattribute__(self, name): ... Получает значение любого атрибута объекта.

### Преобразования типов
- __bool__(self): ................. Определяет, каким образом объект 
                                        преобразуется в булево значение.
                                        
- __bytes__(self): ................ Возвращает байтовое представление объекта.

- __format__(self, format_spec): .. Форматирует объект определенным образом.

- __hash__(self): ................. Вычисляет хэш-код объекта.

- __repr__(self): ................. Строковое представление объекта для отладки.

- __str__(self): .................. Человечески читаемое строковое 
                                        представление объекта.

### Арифметические операторы
- __add__(self, other): ....... Операция сложения (+).

- __sub__(self, other): ....... Операция вычитания (-).

- __mul__(self, other): ....... Умножение (*).

- __truediv__(self, other): ... Деление (/).

- __floordiv__(self, other): .. Целочисленное деление (//).

- __mod__(self, other): ....... Остаток от деления (%).

- __pow__(self, power): ....... Возведение в степень (**).

- __neg__(self): .............. Унарный минус (-obj).

- __pos__(self): .............. Унарный плюс (+obj).

- __abs__(self): .............. Абсолютное значение (abs()).

### Логические операторы
- __eq__(self, other): Проверка равенства (==).

- __ne__(self, other): Проверка неравенства (!=).

- __lt__(self, other): Меньше (<).

- __le__(self, other): Меньше или равно (<=).

- __gt__(self, other): Больше (>).

- __ge__(self, other): Больше или равно (>=).

### Операторы последовательности
- __len__(self): .................  Длина объекта (len()).

- __getitem__(self, key): ......... Доступ к элементу по индексу или ключу.

- __setitem__(self, key, value): .. Установка элемента по индексу или ключу.

- __delitem__(self, key): ......... Удаление элемента по индексу или ключу.

- __iter__(self): ................. Позволяет объекту быть итератором.

- __next__(self): ................. Следующий элемент итератора.

### Контекст-менеджеры
- __enter__(self): ................................ Метод, вызываемый при 
                                                        входе в блок with.
- __exit__(self, exc_type, exc_value, traceback): . Метод, вызываемый при 
                                                        выходе из блока with.

### Дополнительные полезные магические методы

#### Методы управления контейнерами и коллекциями
- __contains__(self, item): ... Позволяет проверять наличие элемента в 
                                коллекции оператором `in`.  
Пример:  
'''
if x in my_collection:
    print("Нашли!")

'''
- __reversed__(self): ......... Реализует обратную последовательность 
                                    элементов для итерации. Используется 
                                    функцией `reversed()`:  
'''
for element in reversed(my_sequence):
    print(element)
'''

- __index__(self): ............ Возвращает целочисленный индекс объекта. 
                                    Используется функциями, такими как 
                                    `bin()`, `hex()`, `oct()`.

#### Работа с числами и преобразования между типами
- __complex__(self): Преобразование объекта в комплексное число.

- __float__(self): ................... Преобразование объекта в вещественное 
                                            число.
                                            
- __int__(self): ...................... Преобразование объекта в целое число.

- __round__(self, ndigits=None): ...... Округление числа.

#### Методы поддержки отражений и метаданных
- __dir__(self): ...................... Список атрибутов и методов объекта.

- __sizeof__(self): ................... Размер объекта в памяти.

- __instancecheck__(cls, instance): ... Проверяет принадлежность объекта 
                                            классу (используется встроенной 
                                            функцией isinstance()).
                                            
- __subclasscheck__(cls, subclass): ... Проверяет наследование подклассов (
                                            используется функцией issubclass()).

#### Потоковые данные и сериализация
- __reduce__(self): ....................... Поддерживает сериализацию через 
                                                модуль pickle.
                                                
- __getstate__(self) / __setstate__(self):  Используются для кастомизации 
                                                процесса сохранения и 
                                                восстановления состояния 
                                                объекта при сериализации.

#### Специфичные типы контейнеров
- __call__(self[, args...]): ...... Позволяет вызывать объект как функцию.  
Пример:  
'''
class Counter:
    def __init__(self):
        self.count = 0

    def __call__(self):
        self.count += 1
        return self.count

counter = Counter()
print(counter())  # 1
print(counter())  # 2
'''

- __missing__(self, key): ..... Метод для обработки отсутствующих ключей в 
                                    мапинге (например, словарь).


### Магические методы для файловых операций и потоков ввода/вывода
- __enter__(self): Этот метод используется совместно с конструкцией `with`, 
                    чтобы обеспечить автоматическое открытие ресурса 
                    (например, файла) при входе в блок `with`.
                    
- __exit__(self, exc_type, exc_val, exc_tb): Метод, выполняемый при 
                    завершении блока `with`, закрывающий ресурс и 
                    обрабатывающий возможные исключения.

Пример:
'''
class FileManager:
    def __init__(self, filename):
        self.filename = filename

    def __enter__(self):
        self.file = open(self.filename, 'w')
        return self.file

    def __exit__(self, type, value, traceback):
        if self.file:
            self.file.close()

with FileManager('example.txt') as file:
    file.write('Привет!')
'''
- __close__(self): .... Используется библиотекой contextlib и позволяет 
                        определять очистку ресурсов 
                        при закрытии файлового потока.

### Асинхронные методы
Python поддерживает асинхронное программирование начиная с версии 3.5. 
Для реализации корутин и ожидания событий применяются 
следующие магические методы:

- __await__(self): .................. Обеспечивает поддержку ожидаемых 
                                            объектов (coroutines).
- __aiter__(self): .................. Формирует итератор для асинхронных 
                                            циклов for.
- __anext__(self): .................. Метод следующего элемента в 
                                            асинхронном итерировании.
- __aenter__(self): ................. Аналог метода `__enter__()` для 
                                            асинхронных блоков `async with`.
- __aexit__(self, exc_type, exc_val, exc_tb): .. Завершение асинхронного 
                                            контекста (аналогично обычному 
                                            выходу из `with`).

Пример асинхронного контекста:
'''
import asyncio

class AsyncFileReader:
    async def __aenter__(self):
        await asyncio.sleep(1)  # Имитация открытия файла
        return self

    async def __aexit__(self, *args):
        pass  # Здесь можно закрыть файл

async def main():
    async with AsyncFileReader() as reader:
        print("Файл открыт")

asyncio.run(main())
'''
### Специальные методы для хранения свойств и мета-программирования
- __slots__(self): .................... Позволяет оптимизировать память, 
                                            определяя фиксированный набор 
                                            атрибутов класса.
                                            
- __metaclass__(self): ................ Определяет используемый метакласс для 
                                            класса (редко применяется в 
                                            современных версиях Python).
                                            
- __prepare__(name, bases, **kwds): ... Подготавливает пространство имен 
                                            класса при создании нового класса 
                                            (определяется в метаклассах).

### Обработка ошибок и исключений
- __cause__(self): .... Связан с механизмом цепочки исключений (PEP 3134), 
                            задаёт причину возникновения текущего исключения.
                            
- __context__(self): ... Запоминает предыдущее исключение, вызвавшее текущее.

- __traceback__(self): . Содержит трассировку стека исключения.

### Другие редкие случаи
- __array__(self): .... Используется модулем NumPy для конвертации объектов в 
                             массивы NumPy.
                             
- __buffer__(self): ... Отвечает за получение буферизованного представления 
                             объекта (больше актуально для низкоуровневой
                             работы с памятью).


### Редко используемые, но важные магические методы

#### 1. **Методы для манипуляции битовыми значениями**
Эти методы полезны, если вам нужно реализовать логику работы с отдельными 
битами, например, в алгоритмах шифрования или сжатия данных.

- __and__(self, other): .... Битовая операция AND  (&)
- __or__(self, other): ..... Битовая операция OR   (|)
- __xor__(self, other): .... Битовая операция XOR  (^)
- __lshift__(self, bits): .. Смещение битов влево  (<<)
- __rshift__(self, bits): .. Смещение битов вправо (>>)
- __invert__(self): ........ Инвертирование битов  (~)

Примеры:
'''
class BitwiseInt(int):
    def __and__(self, other):
        result = super().__and__(other)
        print(f'AND result: {result}')
        return result

num1 = BitwiseInt(10)
num2 = BitwiseInt(6)

print(num1 & num2)  # AND result: 2
'''

#### 2. **Специализированные методы для работы с объектами в отображениях**
Некоторые из этих методов предназначены для оптимизации поведения объектов 
внутри специализированных структур данных, таких как dict-like структуры.

- __missing__(self, key): ......... Определяет реакцию на отсутствие ключа в 
                                        map-последовательностях 
                                        (например, словарь).
                                        
- __copy__(self): ................. Копирует объект поверхностно 
                                        (поверхностная копия).
                                        
- __deepcopy__(self, memo={}): .... Глубокая рекурсивная копирование объекта 
                                        вместе с вложенными структурами.

Использование deep copy и shallow copy полезно, когда объекты содержат 
вложенные структуры, которые нужно аккуратно скопировать.

#### 3. **Методы поддержки функционального стиля программирования**
Эти методы добавляют функциональные возможности вашим классам, делая их 
совместимыми с функциональными инструментами Python, 
такими как лямбда-функции и каррирование.

- __call__(self, ...): .... Позволяет вызвать объект как функцию.

- __func__(self): ......... Используется внутренне при работе с декораторами 
                                функций и замыканиями.

Пример использования call:
'''
class MultiplyByTwo:
    def __call__(self, number):
        return number * 2

double_number = MultiplyByTwo()
print(double_number(5))  # Результат: 10
'''

#### 4. **Методы поддержки сетевых коммуникаций**
Хотя они редко встречаются в повседневном программировании, бывают ситуации, 
когда важно поддерживать протокол обмена данными.

- __getstate__(self): ......... Определён для подготовки объекта к 
                                    сериализации.
                                    
- __setstate__(self, state): .. Применяется при десериализации объекта.

Также важен метод 
__reduce_ex__(protocol_version) .... управляет процессом сериализации и 
                                        обратносовместимостью версий 
                                        протокола Pickle.

#### 5. **Различные мелкие, но важные методы**
- __finalize__(self): ..... Управляет финализацией объекта при удалении 
                                сборщиком мусора (GC).
                                
- __weakref__(self): ...... Добавляет поддержку слабых ссылок на объект (
                                позволяя эффективно управлять памятью).
                                
- __doc__(self): .......... Документирование вашего класса, предоставляя 
                                доступ к документации объекта.

### Практическая польза
Даже если некоторые из этих методов кажутся узконаправленными, они пригодятся, 
когда потребуется глубоко интегрироваться с существующими библиотеками 
или решить конкретные проблемы производительности. Важно помнить, что 
магические методы предоставляют богатые инструменты для тонкой настройки 
поведения объектов в Python.


#### 1. **Методы для работы с ошибками и исключениями**
Помимо тех, что были описаны ранее, есть ещё несколько интересных методов, связанных с обработкой исключений:

- __cause__(self): ................ Определяет причину возникновения 
                                        исключения (связано с механикой 
                                        PEP 3134).
                                        
- __context__(self): .............. Хранит информацию о предыдущем 
                                        исключении, которое привело к 
                                        возникновению текущего.
                                        
- __suppress_context__(self): ..... Если этот метод возвращает `True`, 
                                        информация о контексте предыдущего 
                                        исключения игнорируется.

Пример использования:
'''
try:
    raise ValueError("Ошибка значения")
except Exception as e:
    try:
        raise TypeError("Тип некорректен") from e
    except Exception as new_e:
        print(new_e.__cause__)  # Выведет оригинальное исключение ValueError
'''

#### 2. **Метод для проверки принадлежности к типу или интерфейсу**
Иногда бывает полезно задать специальный интерфейс, чтобы убедиться, 
что объект реализует определённые методы или свойства. Для этого служит метод:

- __instancecheck__(cls, instance): ... Позволяет проверить, является ли 
                                            объект экземпляром заданного типа 
                                            или удовлетворяет указанному 
                                            интерфейсу.

Пример:
'''
class MyClass(metaclass=type):
    @classmethod
    def __instancecheck__(cls, instance):
        return hasattr(instance, 'my_method')

class SomeObject:
    def my_method(self):
        pass

obj = SomeObject()
print(isinstance(obj, MyClass))  # Вернёт True
'''

#### 3. **Поддержка дескрипторов и атрибутов**
Дескрипторы позволяют реализовывать особые механизмы для доступа к атрибутам, 
обеспечивая контроль над чтением, записью и удалением атрибутов. 
Эти методы включают:

- __get__(self, obj, cls=None): ... Извлекает значение атрибута.

- __set__(self, obj, value): ...... Присваивает новое значение атрибуту.

- __delete__(self, obj): .......... Удаляет атрибут.

Пример:
'''
class Descriptor:
    def __get__(self, obj, cls=None):
        return f"Привет от {obj.name}"

class Person:
    greeting = Descriptor()
    def __init__(self, name):
        self.name = name

p = Person("Иван")
print(p.greeting)  # Привет от Иван
'''

#### 4. **Методы для тестирования и профилирования**
Некоторые магические методы помогают организовать тестирование и анализировать 
производительность вашего кода:

- __test__(self): ......... Может использоваться юнит-тестами для 
                                автоматического обнаружения тестов.
                                
- __sizeof__(self): ....... Показывает размер объекта в памяти.

Пример использования sizeof:
'''
import sys

class SimpleClass:
    pass

simple_obj = SimpleClass()
print(sys.getsizeof(simple_obj))
'''

#### 5. **Специальные методы для поддержки синтаксиса аннотаций типов**
Начиная с Python 3.6+, появилась возможность аннотировать аргументы и 
возвращаемые значения. Однако для сложных случаев можно вручную настроить 
поведение аннотаций, используя специальные методы:

- __annotations__(self): ...... Предоставляет доступ к аннотациям аргументов и 
                                    возврата.

Пример:
'''
def add(a: int, b: int) -> int:
    return a + b

print(add.__annotations__)
'''

### Что такое метаклассы?

Метаклассы — это классы, создающие другие классы. Каждый раз, когда вы 
используете ключевое слово `class`, создается новый класс, и этот класс 
тоже является объектом какого-то другого класса — метакласса. 
Стандартный метакласс в Python называется `type`. Именно он создаёт 
новые классы по умолчанию.

Однако вы можете самостоятельно определить собственный метакласс, если 
хотите изменить поведение создаваемых классов на этапе их определения. 
Простой пример:

'''
class Meta(type):
    def __new__(mcs, name, bases, attrs):
        print(f"Создаем класс {name}")
        return super().__new__(mcs, name, bases, attrs)

class MyClass(metaclass=Meta):
    pass
'''
Здесь метакласс перехватывает процесс создания класса и выводит сообщение 
при каждом новом классе.

### Почему метаклассы важны?

По сути, метаклассы дают невероятную силу контролировать и изменять 
внутреннее устройство классов прямо на этапе их объявления. 
Это позволяет внедрять дополнительные правила, ограничения или 
автоматическое поведение, создавая мощные фреймворки и библиотеки. 
Конечно, эта техника требует глубокого понимания внутреннего устройства 
Python, но именно благодаря ей создаются современные системы ORM 
(например, Django ORM), DI-контейнеры и прочие высокоуровневые абстракции.

### Использование магических методов в метаклассах

При написании собственных метаклассов, важно учитывать следующее:

- __new__(cls, name, bases, namespace, **kwargs): . Перехватывается при 
                                                        создании нового класса.
- __init__(cls, name, bases, namespace, **kwargs):  Выполняется после 
                                                        создания класса.
- __call__(cls, *args, **kwargs): ..... Перехватывается при создании 
                                            экземпляра класса.

Используя эти методы, можно динамически добавлять поля, методы или настраивать 
иерархию классов.

### Итоги
Сегодня мы познакомились с большинством ключевых магических методов Python, 
от базовых методов для создания и модификации объектов до экзотических 
способов влияния на внутренние процессы языка, такие как метаклассы. 
Мы узнали, как правильно применять магические методы и почему важно 
осознанно подходить к выбору подходящего инструмента.

Ваш ребёнок сможет извлечь огромную пользу из понимания магических методов, 
применяя их для повышения удобства, выразительности и эффективности своего 
кода. Надеюсь, этот материал вдохновил вас продолжить обучение и исследовать 
Python ещё глубже!

Желаю продуктивного обучения и больших успехов вашему ребенку в освоении 
программирования!
'''