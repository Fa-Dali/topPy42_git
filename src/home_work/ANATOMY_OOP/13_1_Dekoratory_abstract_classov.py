### ДЕКОРАТОРЫ АБСТРАКТНЫХ КЛАССОВ

'''
Да, декораторы абстрактных классов имеют некоторые важные особенности и
нюансы, которые стоит учитывать при разработке приложений на Python.
Давайте рассмотрим их подробно:

### Особенности декораторов абстрактных классов:

#### 1. Необходимость импорта специального модуля
Для использования абстрактных классов и абстрактных методов необходимо
импортировать специальный модуль `abc` (Abstract Base Classes).
Без этого нельзя применять декораторы
`@abstractmethod`,
`@abstractclassmethod`,
`@abstractstaticmethod` и другие.

'''
from abc import ABC, abstractmethod
'''

Без импорта указанного модуля интерпретатор выдаст ошибку при попытке 
воспользоваться этими конструкциями.

#### 2. Методы, помеченные декоратором `@abstractmethod`
Методы, которые отмечены декоратором `@abstractmethod`, называются 
абстрактными методами. Такие методы обязательно должны быть переопределены 
в любом конкретном классе-наследнике. В противном случае при создании 
экземпляра такого класса возникнет исключение.

**Пример**:
'''
from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def make_sound(self):
        pass

class Dog(Animal):
    def make_sound(self):
        print("Woof!")

dog = Dog()  # Будет успешно, так как Dog реализует абстрактный метод
animal = Animal()   # Возникнет ошибка,
                    # так как Animal является абстрактным классом
'''

#### 3. Наследование от абстрактного класса
Наследующий класс должен реализовать все абстрактные методы родительского 
абстрактного класса. Пока хотя бы один абстрактный метод не реализован, 
невозможно создать экземпляр этого класса.

**Пример**:
'''
class AbstractBaseClass(ABC):
    @abstractmethod
    def do_something(self):
        pass

class ConcreteClass(AbstractBaseClass):
    def do_something(self):
        print("Doing something...")

obj = ConcreteClass()   # Будет успешно, так как ConcreteClass реализует
                        # абстрактный метод
'''

#### 4. Свойства абстрактных классов
Кроме абстрактных методов, классы могут содержать абстрактные свойства. 
Эти свойства определяются с помощью декораторов 
`@property` и 
`@abstractmethod`.

**Пример**:
'''
class TemperatureSensor(ABC):
    @property
    @abstractmethod
    def temperature(self):
        pass

class Thermometer(TemperatureSensor):
    _temperature = 25

    @property
    def temperature(self):
        return self._temperature

thermometer = Thermometer() # Будет успешно, так как Thermometer реализует
                            # свойство temperature
'''

#### 5. Поддержка статических и классовых методов
Абстрактные классы поддерживают также абстрактные статические и классовые 
методы с помощью специальных декораторов 
`@abstractstaticmethod` и 
`@abstractclassmethod`.

**Пример**:
'''
class Calculator(ABC):
    @staticmethod
    @abstractmethod
    def add(a, b):
        pass

class SimpleCalculator(Calculator):
    @staticmethod
    def add(a, b):
        return a + b

calculator = SimpleCalculator.add(1, 2)  # Будет успешно возвращено 3
'''

#### 6. Проверка принадлежности к абстрактному классу
Модуль `abc` предоставляет специальную функцию `isinstance(obj, cls)` 
для проверки, принадлежит ли объект данному абстрактному классу. 
Эта проверка полезна, если нужно убедиться, что объект реализует 
заданный интерфейс.

**Пример**:
'''
from abc import ABC

class Vehicle(ABC):
    pass

class Car(Vehicle):
    pass

my_car = Car()
print(isinstance(my_car, Vehicle))  # True
'''

#### 7. Полезность для документирования API
Абстрактные классы служат хорошим инструментом для описания интерфейса API и 
обеспечивают строгий контроль над соответствием интерфейсу. Благодаря этому 
документация становится яснее, а программистам проще понимать ожидания по 
отношению к классу.

### Заключение
Используя декораторы абстрактных классов грамотно, вы получаете следующие 
преимущества:
- Четкость и прозрачность интерфейса,
- Удобство сопровождения кода благодаря жёстким требованиям к реализации 
        методов,
- Возможность чёткого разделения общих интерфейсов и конкретных реализаций.

Следуйте правилам использования абстрактных классов, чтобы ваш код стал чище, 
надежнее и легче сопровождаемым.

========================================================================
                СПИСОК ДЕКОРАТОРОВ АБСТРАКТНЫХ КЛАССОВ
========================================================================

Перечисленные четыре декоратора охватывают весь спектр 
возможных случаев для создания абстрактных элементов:

1. **`@abstractmethod`** — для абстрактных методов.
2. **`@abstractclassmethod`** — для абстрактных методов класса.
3. **`@abstractstaticmethod`** — для абстрактных статических методов.
4. **`@abstractproperty` (устаревший)** — раньше использовался для 
        абстрактных свойств, заменён сочетанием 
        ''' # @property и @abstractmethod
'''
Однако, помимо специализированных декораторов абстрактных классов, есть и 
другие стандартные декораторы, применяемые совместно с абстрактными 
классами, например:
- **`@final`** — запрещает дальнейшее переопределение метода в подклассах.
- **`@override`** — подсказывает разработчику, что метод точно переопределяет 
        метод родителя (это чисто информативный декоратор и действует скорее 
        как комментарий, предупреждающий о намеренном переопределении).

Хотя эти дополнительные декораторы (`@final`, `@override`) формально 
не относятся исключительно к абстрактным классам, они могут использоваться 
вместе с абстрактными методами и свойствами для улучшения дизайна и 
документации вашего кода.

Итоговый перечень полезных декораторов, связанных с абстрактными классами:
- **Специфически абстрактные:**  
  - `@abstractmethod`  
  - `@abstractclassmethod`  
  - `@abstractstaticmethod`  
  - - - `@abstractproperty` - УСТАРЕВШИЙ И ЗАМЕНЁН НА
                             @property + @abstractmethod

- **Дополнительные вспомогательные:**  
  - `@final`  
  - `@override` (хотя этот декоратор официально не входит в стандартную 
        библиотеку Python, его аналог можно реализовать самостоятельно 
        для лучшей поддержки OOP-программирования).

Это исчерпывающий список инструментов, доступных для работы с абстрактными 
классами в Python.

ПРИМЕРЫ:

В абстрактных классах в Python используются специальные декораторы 
из модуля `abc` (Abstract Base Classes). Вот полный список основных 
декораторов, предназначенных специально для работы с абстрактными классами:

### Основные декораторы абстрактных классов:

1. **`@abstractmethod`**  
   Используется для обозначения метода как абстрактного. Такой метод 
   обязателен для реализации в каждом классе-потомке.
'''
from abc import ABC, abstractmethod

class MyAbstractClass(ABC):
   @abstractmethod
   def my_method(self):
       pass
'''
2. **`@abstractclassmethod`**  
   Применяется для определения абстрактных методов класса. Подобно обычному 
   методу класса, но требует обязательного переопределения в классе-наследнике.
'''
from abc import ABC, abstractclassmethod

class MyAbstractClass(ABC):
   @abstractclassmethod     # УСТАРЕВШЕЕ : ЧИТАЙ ДАЛЕЕ
   def factory(cls):
       pass
'''
3. **`@abstractstaticmethod`**  
   Позволяет объявить абстрактный статический метод. Статический метод 
   не принимает аргумент `self` или `cls`, 
   но обязательно должен быть переопределён в потомках.
'''
from abc import ABC, abstractstaticmethod

class MyAbstractClass(ABC):
   @abstractstaticmethod     # УСТАРЕВШЕЕ : ЧИТАЙ ДАЛЕЕ
   def helper_function():
       pass
'''
4. **`@abstractproperty` (устаревший)**  
   Ранее использовался для обозначения свойств как абстрактных. 
   Сейчас рекомендуется использовать комбинацию декораторов 
   `@property` и `@abstractmethod`.
        **Современный подход:**  
   Вместо устаревшего `@abstractproperty` используют следующее решение:
'''
from abc import ABC, abstractmethod

class MyAbstractClass(ABC):
   @property
   @abstractmethod
   def some_property(self):
       pass
'''
### Дополнительные рекомендации:
- Используйте декораторы в правильной последовательности: сначала идут 
    специфические декораторы
        `@abstractmethod`, 
        `@abstractclassmethod`, 
        `@abstractstaticmethod`), 
    а затем общие декораторы
        `@property`, 
        `@classmethod`, 
        `@staticmethod`).
- Все абстрактные элементы (методы, свойства) 
    должны быть реализованы в наследниках абстрактного класса.

Таким образом, соблюдая данные правила и пользуясь указанными декораторами, 
вы сможете эффективно проектировать иерархию классов с абстрактными элементами.

========================================================================
            УСТАРЕВШИЕ ДЕКОРАТОРЫ
========================================================================

Вероятно, причина заключается в следующем:

- Декоратора `@abstractclassmethod` 
не существует в стандартной библиотеке Python начиная с версии 3.x. 
Его использование считается устаревшим и было удалено из официальной 
документации.

Начиная с Python 3, правильный способ создания абстрактных методов класса 
— это объединить два декоратора: 
    `@classmethod` и 
    `@abstractmethod`. 
Точно так же поступают и с абстрактными статическими методами, совмещая 
    `@staticmethod` и 
    `@abstractmethod`.

Поэтому правильным вариантом будет следующий синтаксис:
'''
from abc import ABC, abstractmethod

class MyClass(ABC):
    @classmethod
    @abstractmethod
    def my_class_method(cls):
        pass
'''

### Причины, почему PyCharm подчеркивает ваше использование красным цветом:
1. **Удалённое название декоратора:**  
   Возможно, IDE распознала старый декоратор и отметила его как устаревший или 
   неизвестный элемент.

2. **Типичная рекомендация:**  
   Когда вы используете старую или нестандартную форму, современные 
   инструменты, такие как PyCharm, предлагают заменить её рекомендуемым 
   современным способом, чтобы ваш код оставался чистым и соответствующим 
   актуальным стандартам.

---

### Правильный подход:

Всегда старайтесь использовать актуальные конструкции языка. 
Текущие рекомендации по использованию абстрактных методов класса и 
статических методов выглядят так:

- Для абстрактных методов класса:  
'''
@classmethod
@abstractmethod
def my_class_method(cls):
  pass
'''

- Для абстрактных статических методов:  
'''
@staticmethod
@abstractmethod
def my_static_method():
  pass
'''

Исправляя ваш код, используя рекомендованный подход, PyCharm перестанет 
подчеркивать строки с такими декларациями, и ваш код останется 
стабильным и надёжным.

========================================================================
        АБСТРАКТНЫЙ КЛАСС ДЛЯ АБСТРАКТНЫХ
========================================================================

            Читай: 13_2_Abstract_for_Abstract.py

========================================================================
        ДЛЯ МЕБЕЛЬНОГО ПРОИЗВОДСТВА
========================================================================

Хороший вопрос! Представим фабрику по производству мебели, где мы хотим 
использовать абстрактные классы и соответствующие декораторы для лучшего 
проектирования нашего кода. Попробуем рассмотреть применение каждого из 
указанных декораторов на практическом примере.

### Пример: Финансовая система учета на мебельной фабрике

Допустим, наша фабрика выпускает три вида продукции: деревянные кровати, 
мягкие диваны и кухни на заказ. Нам нужно описать общее поведение продуктов, 
выделив абстрактные классы и обеспечив соблюдение контрактов для каждой 
категории товаров.

### Шаг 1: Определение базовых абстрактных классов
Мы создадим абстрактный класс `Product`, который будет служить базой 
для всех наших видов продукции. Он будет включать базовые операции, 
характерные для любого продукта на нашем предприятии.
'''
from abc import ABC, abstractmethod

class Product(ABC):
    """Базовый абстрактный класс для всей нашей продукции."""

    @abstractmethod
    def calculate_cost(self):
        """Рассчитываем себестоимость изделия"""
        pass

    @abstractmethod
    def display_details(self):
        """Показываем детальную информацию о продукте"""
        pass

    @classmethod
    @abstractmethod
    def create_from_data(cls, data):
        """Создание продукта из входных данных"""
        pass

    @staticmethod
    @abstractmethod
    def validate_input(data):
        """Проверяем правильность ввода данных для продукта"""
        pass
'''
### Шаг 2: Применение декораторов на практике
Теперь давайте посмотрим, как применяются наши декораторы 
в конкретной реализации.

#### 1. `@abstractmethod`
Данный декоратор применяется для методов, которые обязательно 
должны быть реализованы в конкретных продуктах.
'''
class Bed(Product):
    def __init__(self, wood_type, dimensions):
        self.wood_type = wood_type
        self.dimensions = dimensions

    def calculate_cost(self):
        return len(self.wood_type) * 100  # Простая логика расчета стоимости

    def display_details(self):
        print(f"Кровать из {self.wood_type}, размером {self.dimensions}")

    @classmethod
    def create_from_data(cls, data):
        return cls(data["wood"], data["dimensions"])

    @staticmethod
    def validate_input(data):
        required_fields = ["wood", "dimensions"]
        for field in required_fields:
            if field not in data:
                return False
        return True
'''

Каждый метод, отмеченный `@abstractmethod`, гарантирует наличие 
соответствующей реализации в классах-продуктах, обеспечивая совместимость и 
надежность нашего ПО.

#### 2. `@abstractclassmethod`
Позволяет нам определять абстрактные методы уровня класса, которые будут 
применяться ко всему типу продукта, а не к отдельным объектам.
'''
class Sofa(Product):
    @classmethod
    def create_from_data(cls, data):
        return cls(data["fabric"], data["color"])

    @classmethod
    def recommend_fabric(cls):
        return "Рекомендуемый материал — лен."
'''
#### 3. @staticmethod
        @abstractmethod
Используется для абстрактных статических методов, не зависящих от состояния 
конкретного объекта или класса.
'''
class KitchenSet(Product):
    @staticmethod
    def validate_input(data):
        if "cabinets" not in data or "appliances" not in data:
            return False
        return True
'''
#### 4. Другие декораторы (`@final`, `@override`)
Эти декораторы не входят в стандартный пакет Python, но можно использовать 
стороннюю поддержку (например, через библиотеки или собственное определение). 
Хотя их поддержка необязательна, они помогают улучшить дизайн и документацию 
вашего кода.

Например, вы могли бы написать вспомогательную реализацию `@final` 
для предотвращения переопределения критического метода:
'''
def final(func):
    func.__final__ = True
    return func

class FinalMethodExample:
    @final
    def cannot_override_me(self):
        print("This method should never be overridden.")
'''

### Резюме
- **`@abstractmethod`** используется для абстрактных методов, которые
        обязательно должны быть реализованы в каждом классе-наследнике.

- **@classmethod 
    @abstractmethod** позволяет обеспечить реализацию методов класса,
        относящихся к общему поведению группы продуктов.

- **@staticmethod
    @abstractmethod** полезен для проверки валидности входных данных
        или создания универсальной логики вне контекста отдельных объектов.
        
- Дополнительно можно внедрить вспомогательные декораторы
    `@final`,
    `@override`),
    чтобы поддерживать чистоту интерфейса и предотвратить нежелательное
    переопределение ключевых методов.

Такой подход позволит вашему проекту стать устойчивее, прозрачнее
и проще в поддержке.

========================================================================
            ЕЩЕ ПРИМЕРЫ ДЛЯ МЕБЕЛЬНОГО
========================================================================

Хорошо, продолжим демонстрацию применения абстрактных классов и декораторов 
на примерах, касающихся мебельного производства. Добавим несколько 
практических сценариев и ситуаций, которые встречаются в реальной жизни 
на предприятиях подобного профиля.

### Примеры использования абстрактных классов и декораторов в мебельном 
    производстве

#### 1. Разделение производства по материалам
##### Задача: Создание дерева материалов и способов обработки.
'''
from abc import ABC, abstractmethod

class MaterialProcessor(ABC):
    @abstractmethod
    def prepare_material(self):
        pass

class Wood(MaterialProcessor):
    def prepare_material(self):
        print("Подготовка древесины: сушка, шлифовка.")

class Metal(MaterialProcessor):
    def prepare_material(self):
        print("Подготовка металла: гальваника, окраска.")
'''
#### 2. Организация цехов по обработке деталей
##### Задача: Абстрактный класс для цеха с различными операциями.
'''
class Workshop(ABC):
    @abstractmethod
    def cut_pieces(self):
        pass

    @abstractmethod
    def polish_edges(self):
        pass

class CarpentryWorkshop(Workshop):
    def cut_pieces(self):
        print("Раскрой древесных плит.")

    def polish_edges(self):
        print("Шлифовка кромок.")
'''
#### 3. Автоматизированные линии производства
##### Задача: Организация автоматических линий, работающих 
              с разными материалами.
'''
class AssemblyLine(ABC):
    @abstractmethod
    def load_material(self):
        pass

    @abstractmethod
    def perform_assembly(self):
        pass

class RoboticAssemblyLine(AssemblyLine):
    def load_material(self):
        print("Автоматическая загрузка материала.")

    def perform_assembly(self):
        print("Роботы собирают изделие.")
'''
#### 4. Логистика готовой продукции
##### Задача: Контроль доставки и складирования готовых изделий.
'''
class WarehouseManagement(ABC):
    @abstractmethod
    def store_item(self):
        pass

    @abstractmethod
    def deliver_to_customer(self):
        pass

class ModernWarehouse(WarehouseManagement):
    def store_item(self):
        print("Складирование с использованием автоматизированных систем.")

    def deliver_to_customer(self):
        print("Доставка клиенту логистической службой.")
'''
#### 5. Управление персоналом
##### Задача: Работа с сотрудниками разного уровня квалификации.
'''
class Employee(ABC):
    @abstractmethod
    def work_shift(self):
        pass

class Master(Employee):
    def work_shift(self):
        print("Мастер руководит работой бригады.")

class Apprentice(Employee):
    def work_shift(self):
        print("Учится под руководством мастера.")
'''
#### 6. Качество продукции
##### Задача: Инспекция качества на этапах производства.
'''
class QualityControl(ABC):
    @abstractmethod
    def inspect(self):
        pass

class Inspector(QualityControl):
    def inspect(self):
        print("Инспектор проводит проверку соответствия стандартам.")
'''
#### 7. Оптимизация производственных процессов
##### Задача: Анализ эффективности производственного цикла.
'''
class ProcessOptimizer(ABC):
    @abstractmethod
    def analyze_process(self):
        pass

class AIProcessOptimizer(ProcessOptimizer):
    def analyze_process(self):
        print("Искусственный интеллект оптимизирует "
              "производственные процессы.")
'''
#### 8. Планирование закупок сырья
##### Задача: Абстрактный класс для планирования закупки ресурсов.
'''
class ProcurementPlanner(ABC):
    @abstractmethod
    def plan_purchase(self):
        pass

class CentralProcurementOffice(ProcurementPlanner):
    def plan_purchase(self):
        print("Центральный отдел планирует закупку материалов.")
'''
#### 9. Сертификация и маркировка продукции
##### Задача: Выполнение сертификации и оформление документов.
'''
class CertificationService(ABC):
    @abstractmethod
    def certify_product(self):
        pass

class LocalCertificationCenter(CertificationService):
    def certify_product(self):
        print("Оформление сертификатов соответствия российским нормам.")
'''
#### 10. Реклама и продвижение продукции
##### Задача: Организация рекламных кампаний 
              для продвижения новой линейки мебели.
'''
class MarketingCampaign(ABC):
    @abstractmethod
    def run_campaign(self):
        pass

class DigitalMarketing(MarketingCampaign):
    def run_campaign(self):
        print("Запуск онлайн рекламной кампании.")
'''
### Заключение
Эти примеры показали разнообразие возможностей, предоставляемых 
абстрактными классами и соответствующими декораторами. 
От обработки материалов до автоматизации производства 
и маркетинговых стратегий — абстрактные классы становятся 
мощным инструментом для моделирования сложных бизнес-процессов 
и организаций, позволяя унифицировать и упростить разработку 
программного обеспечения.
'''