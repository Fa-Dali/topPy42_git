# 5_static_methods.py

'''
Статические методы (static methods) в Python — это специальные методы класса,
                    которые не связаны с каким-либо конкретным экземпляром
                    объекта. Статический метод не получает никакого
                    специального первого аргумента
                    (такого как `self` или `cls`), и его можно вызывать как
                    через класс, так и через экземпляр.

Основная цель статических методов — инкапсулировать некоторую полезную логику,
связанную с самим классом, но не зависящую от состояния отдельных объектов
этого класса.

### Основные особенности статических методов:

1. **Независимость от экземпляров**

   Статический метод не имеет доступа к атрибутам экземпляра (`self`),
   поскольку он не принимает объект в качестве первого аргумента.
   Его задача — выполнять независимые вычисления или действия, общие
   для всего класса.

'''
class MathUtils:
   @staticmethod
   def sum(a, b):
       return a + b
'''

2. **Использование декоратора `@staticmethod`**

   Чтобы объявить метод статическим, используется декоратор `@staticmethod`. 
   Без этого декоратора обычный метод экземпляра ожидает передачу 
   объекта (`self`), что приведет к ошибке.

'''
class Utils:
   @staticmethod
   def is_even(number):
       return number % 2 == 0
'''

3. **Совместимость с наследованием**

   Статические методы работают одинаково хорошо в производных классах. 
   Поскольку они не зависят от конкретного экземпляра, их поведение остается 
   неизменным даже при наследовании.

'''
class BaseClass:
   @staticmethod
   def say_hello():
       print("Hello from base class")

class DerivedClass(BaseClass):
   pass

derived_obj = DerivedClass()
derived_obj.say_hello()  # Hello from base class
'''

4. **Роль в организации кода**

   Использование статических методов позволяет структурировать код и избегать 
   глобальных функций. Вместо разбросанных функций вне классов, такие 
   вспомогательные методы помещаются внутрь классов, улучшая организацию и 
   модульность кода.

'''
class StringHelper:
   @staticmethod
   def reverse_string(s):
       return s[::-1]
'''

5. **Разница между статическими и обычными методами**

   Обычные методы экземпляра получают объект (`self`) в качестве первого 
   аргумента и имеют доступ к внутренним данным объекта. Статические методы 
   не требуют и не ожидают объект, выполняя независимую операцию.

'''
class Person:
   def __init__(self, age):
       self.age = age

   @staticmethod
   def calculate_age_difference(age1, age2):
       return abs(age1 - age2)
'''

================================================
### Практическое применение статических методов:
================================================
- Вспомогательная логика, общая для всех объектов класса (например, проверка 
        валидности данных, преобразование типов и т.д.)
- Реализация общих утилитарных функций, используемых различными частями 
        приложения.
- Обеспечение независимости от состояний объектов и улучшение тестируемости 
        кода.

Пример реальной задачи:

'''
import math

class GeometryCalculator:
    @staticmethod
    def circle_area(radius):
        return math.pi * radius ** 2

GeometryCalculator.circle_area(5)  # Вернёт площадь круга радиусом 5
'''

### Резюме:

Статические методы полезны для случаев, когда нужно реализовать общую логику, 
относящуюся к классу, но не зависящую от состояния конкретного объекта. 
Их использование способствует улучшению структуры кода, уменьшению зависимости 
от внешних компонентов и повышению читаемости решений.

==============================================
                ТОНКОСТИ И НЮАНСЫ
==============================================
В дополнение к основному материалу о статических методах, давайте обсудим 
некоторые важные тонкости и практические аспекты их использования в Python OOP.

### Тонкости и особенности статических методов:

#### 1. **Назначение и цели использования**

Хотя многие разработчики знают, что статические методы существуют, часто 
возникает вопрос: когда именно их применять? Вот несколько практических 
ситуаций, когда статические методы подходят наилучшим образом:

- Логика, связанная с классом, но не требующая доступа к состоянию объекта 
        (например, расчеты, преобразования, проверки).
- Инструменты-конвертеры или помощники, используемые повсеместно в приложении.
- Конструктор фабричных паттернов (фабрика создает объекты класса, 
        не взаимодействуя с существующими экземплярами).

'''
class FileManager:
    @staticmethod
    def validate_file_extension(file_path):
        """ Проверяет расширение файла """
        return file_path.endswith('.txt')
'''

#### 2. **Интероперабельность с наследованием**

Статические методы прекрасно интегрируются с механизмами наследования. 
Производные классы могут унаследовать статические методы родительского 
класса без проблем, сохраняя их первоначальное поведение.

'''
class Animal:
    @staticmethod
    def make_sound():
        print("Животные общаются...")

class Dog(Animal):
    pass

dog = Dog()
dog.make_sound()  # Животные общаются...
'''

#### 3. **Контроль доступа и изоляция**

Поскольку статические методы не влияют на внутреннее состояние объекта, 
их можно рассматривать как своего рода защиту от побочных эффектов. 
Это означает, что вы можете быть уверены, что выполнение статического метода 
не затронет состояние объекта или изменит внешний вид системы.

#### 4. **Минимизация нагрузки на память**

Так как статические методы не связывают себя с каждым отдельным экземпляром 
объекта, они занимают меньше памяти и ресурсов, чем обычные методы экземпляра. 
Особенно актуально это при работе с большим количеством объектов.

#### 5. **Возможность замены на свободные функции**

Важно отметить, что в большинстве случаев вы могли бы заменить статический 
метод свободной функцией, вынесенной наружу класса. Тем не менее, включение 
статических методов внутрь класса повышает читаемость и подчеркивает связь с 
общей концепцией класса.

'''
# Свободная функция вне класса
def calculate_distance(x1, y1, x2, y2):
    dx = x2 - x1
    dy = y2 - y1
    return math.sqrt(dx*dx + dy*dy)

# Альтернатива в виде статического метода
class Point:
    @staticmethod
    def distance_between_points(x1, y1, x2, y2):
        return ((x2-x1)**2 + (y2-y1)**2) ** 0.5
'''

#### 6. **Интеграция с классовыми методами**

Нередко возникают ситуации, когда необходимо объединить возможности 
статических и обычных методов класса. Классовые методы (`@classmethod`) 
предоставляют альтернативу, предоставляя доступ к самому классу (`cls`), 
но без связи с состоянием объекта.

'''
class Book:
    COUNTER = 0

    @classmethod
    def create_book(cls, title):
        cls.COUNTER += 1
        return cls(title)

    @staticmethod
    def format_title(title):
        return title.upper()
'''

#### 7. **Проблемы видимости и ограничений**

Несмотря на преимущества статических методов, 
важно учитывать потенциальные проблемы:
- Невозможность обратиться к состоянию объекта (метод ограничен работой 
        исключительно с входящими аргументами).
- Потеря наглядности, если метод назван недостаточно информативно или 
        плохо вписывается в контекст класса.

#### 8. **Документирование и аннотации**

При написании документации рекомендуется детально разъяснять назначение 
статических методов, особенно если они выполняют сложную обработку или 
играют важную роль в архитектуре приложения.

'''
class DataProcessor:
    @staticmethod
    def normalize_data(data):
        """ Нормализует входящий массив данных """
        return [d/100 for d in data]
'''

---

### Важные моменты для запоминания:

- Статические методы не меняют состояние объекта и предназначены 
        для независимой логики.
- Эффективны при обработке данных или осуществлении проверок, общих 
        для всей иерархии классов.
- Легко сочетаются с наследованием и остаются полезными инструментами 
        для улучшения архитектуры приложений.

Следуя этим рекомендациям, вы сможете грамотно интегрировать статические 
методы в свою программу, обеспечивая высокую эффективность и 
надежность решения.

Помимо базовых аспектов, которые мы рассмотрели ранее, есть еще несколько 
важных моментов и трюков, касающихся статических методов в Python. 
Я расскажу о них ниже, чтобы ваше понимание стало глубже и разнообразнее.

---

### Дополнительные аспекты статических методов:

#### 1. **Использование вместе с абстрактными классами (ABC)**

Абстрактные базовые классы (Abstract Base Classes) позволяют определять 
интерфейс и требовать реализацию определенных методов дочерними классами. 
Интересно, что статические методы тоже могут играть роль части 
абстрактного интерфейса.

'''
from abc import ABC, abstractmethod

class AbstractMathOperations(ABC):
    @abstractmethod
    @staticmethod
    def compute_area(shape):
        raise NotImplementedError

class Rectangle(AbstractMathOperations):
    @staticmethod
    def compute_area(width, height):
        return width * height
'''

Здесь метод `compute_area` объявлен как абстрактный статический метод, 
который обязателен для реализации всеми подклассами.

#### 2. **Статические методы как фабрики (Factory Pattern)**

Статические методы могут служить фабриками для создания различных видов 
объектов класса, управляемых внутренними правилами или условиями.

'''
class Vehicle:
    @staticmethod
    def factory(type):
        if type == 'car':
            return Car()
        elif type == 'bike':
            return Bike()
        else:
            raise ValueError('Unknown vehicle type')

class Car(Vehicle):
    pass

class Bike(Vehicle):
    pass
'''

Это простой способ унифицировать создание объектов, облегчающий 
масштабирование и поддержание согласованности.

#### 3. **Статические методы и кеширование результатов**

Статические методы можно использовать совместно с механизмом мемоизации 
(кеширования) для оптимизации повторяющихся вычислений. Модуль `functools` 
предлагает удобную реализацию кеширования через декоратор `lru_cache`.

'''
import functools

class Calculator:
    @staticmethod
    @functools.lru_cache(maxsize=None)
    def factorial(n):
        if n <= 1:
            return 1
        return n * Calculator.factorial(n-1)
'''

Теперь каждое вычисление факториала будет кэшироваться, 
ускоряя последующие обращения.

#### 4. **Объединение статических методов с @dataclass**

Модуль `dataclasses` позволяет легко создавать классы данных, и статические 
методы могут удачно дополнять такую концепцию. Вы можете использовать 
статические методы для нормализации или предварительной обработки данных.

'''
from dataclasses import dataclass

@dataclass
class Person:
    first_name: str
    last_name: str

    @staticmethod
    def full_name(first_name, last_name):
        return f"{first_name} {last_name}"
'''

#### 5. **Использование статических методов для загрузки настроек**

Иногда полезно сохранять статические методы для чтения или обновления 
глобальных настроек, применимых ко всем объектам класса.

'''
class AppConfig:
    DEFAULT_SETTING = {'theme': 'light'}

    @staticmethod
    def update_setting(key, value):
        AppConfig.DEFAULT_SETTING[key] = value
'''

Теперь любой объект класса сможет обновить глобальную настройку.

#### 6. **Имитация singleton'a (паттерн одиночки)**

Можно использовать статические методы для управления созданием единственного 
экземпляра класса (singleton pattern).

'''
class Singleton:
    _instance = None

    @staticmethod
    def instance():
        if Singleton._instance is None:
            Singleton._instance = Singleton()
        return Singleton._instance
'''

Таким образом обеспечивается гарантия существования 
ровно одного экземпляра класса.

#### 7. **Советы по документированию**

Документируйте статические методы аккуратно и подробно, поясняя, какие условия 
выполняются при их вызове и какова область ответственности каждой функции. 
Помните, что хорошая документация спасает часы потраченного времени на отладку.

'''
class Helper:
    @staticmethod
    def clean_text(text):
        """
        Удаляет лишние пробелы и символы переноса строки из текста.

        :param text: Исходный текст
        :type text: str
        :return: Отформатированный текст
        :rtype: str
        """
        return ''.join(text.split())
'''

### Советы по использованию статических методов:

- Избегайте злоупотребления статическими методами. Определитесь с четкой целью 
        и ограничивайте их влияние на бизнес-логику.
- Помните, что статические методы обладают ограниченной областью применения и 
        не могут влиять на внутренний state (состояние) объекта.
- Используйте staticmethods, когда ваша логика действительно относится к 
        общему поведению класса, а не конкретного объекта.


Таким образом, правильное использование статических методов позволяет повысить 
эффективность и поддерживать чистоту дизайна классов. Следуя перечисленным 
советам и примерам, вы получите более мощные инструменты для разработки 
высокопроизводительных и устойчивых приложений.
'''