### АНАТОМИЯ КЛАССОВ

class Кот:
    число_лап = 4       ### 1
                        # АТРИБУТЫ КЛАССА - индивидуальные характеристики
                        # конкретного объекта (например, имя кота)
    ### 3
    # КОНСТРУКТОР — специальный метод, автоматически вызываемый
    #               при создании нового объекта. Обычно используется для
    #               инициализации атрибутов экземпляра.
    def __init__(self, имя):
        self.имя = имя  ### 2
                        # АТРИБУТЫ ЭКЗЕМПЛЯРА: общие характеристики всех
                        #                      экземпляров класса (например,
                        #                      количество лап у кошек)

    ### 4
    # МЕТОДЫ ЭКЗЕМПЛЯРА: принимают первый аргумент self,
    #                    ссылающийся на экземпляр объекта.
    def мяукнуть(self):
        print(f'{self.имя}: Мяу!')

    ### 5
    # СТАТИЧЕСКИЙ МЕТОД: независимые от конкретных экземпляров,
    #                    используются для общих операций.
    @staticmethod
    def посчитать_кошек():
        return 'У меня много друзей!'

    ### 6
    # МЕТОДЫ КЛАССА: работают с самим классом,
    #                имеют доступ к атрибутам класса через аргумент cls.
    @classmethod
    def изменить_число_лап(cls, новое_количество):
        cls.число_лап = новое_количество

    ### 7
    # ДЕСТРУКТОР — метод, выполняемый перед удалением объекта из памяти.
    #              Редко используется, чаще всего память освобождается
    #              автоматически сборщиком мусора.
    def __del__(self):
        print('Прощайте, мир...')

# ======================================================================

### 8
''' 
    8_0_properties.py 
    8_1_property_varyables.py
'''
# СВОЙСТВА (property) - позволяет создавать удобные интерфейсы
#                     для чтения/изменения значений атрибутов.
#                     Можно добавлять проверку данных
#                     и другие полезные операции.
class Человечек:
    # Скрытый атрибут для хранения реального роста
    def __init__(self, рост):
        self._рост = рост  # начальное значение сразу присваивается нормально

    # Получаем рост спокойно
    @property
    def рост(self):
        return self._рост

    # Устанавливаем рост осторожно
    @рост.setter
    def рост(self, значение):
        if значение > 0:
            self._рост = значение
        else:
            raise ValueError("Рост не может быть отрицательным.")

# Создание персонажа
герой = Человечек(170)

# Попробуем установить нормальный рост
герой.рост = 180
print(герой.рост)  # Всё отлично! Рост установлен: 180 см

# А попробуем поставить неверный рост (-10)
герой.рост = -10  # Тут выскочит ошибка: ValueError: Рост не может быть отрицательным.

# ======================================================================

### 9
'''
9_0_magical_methods.py
'''
# СПЕЦИАЛЬНЫЕ МЕТОДЫ («магические методы»)
#                    позволяют переопределять поведение стандартных
#                    операторов и функций, такие как сложение (+),
#                    преобразование в строку (str()), итерация (iter()).
#                    Примеры магических методов:
# __add__: переопределяет оператор сложения.
# __len__: возвращает длину объекта.
# __repr__: формирует представление объекта в виде строки.
# ...
class Строка:
    def __init__(self, буквы):
        self.буквы = буквы

    def __add__(self, другой):
        return Строка(self.буквы + другой.буквы)

# ======================================================================

### 10
# ИНКАПСУЛЯЦИЯ - сокрытие внутренней реализации объекта и предоставление
#               безопасного внешнего интерфейса. Она достигается использованием
#               приватных атрибутов (начинаются с символа _ или __) и методов.
class Танк:
    def __init__(self):
        self.экипаж = 12        # Public
                                # ДОСТУПЕН ВСЕМ
        self._топливо = 50      # Protected
                                # ДОСТУПЕН Т! СЕБЕ И ДОЧЕРНИМ КЛАССАМ
        self.__боезапас = 100   # Privat
                                # ДОСТУПЕН Т! СЕБЕ - Приватный атрибут

# ======================================================================

### 11
# НАСЛЕДОВАНИЕ - позволяет одному классу наследовать свойства и методы
#                другого класса. Это помогает избежать дублирования кода и
#                упрощает поддержку проектов.
class Автомобили:
    def сигналить(self):
        print('Би-би!')

class ГоночнаяМашина(Автомобили):
    def ускоряться(self):
        print('Ж-ж-ж-ж')

# ======================================================================

### 12
# ПОЛИМОРФИЗМ — способность одного имени обозначать различные действия
#               в зависимости от контекста.
#               Часто реализуется через перегрузку методов.
class Птица:
    def петь(self):
        print('Птичка чирикает.')

class Кошка:
    def петь(self):
        print('Кошечка мурлычет.')

# Использование обоих методов одним способом
животные = [Птица(), Кошка()]
for животное in животные:
    животное.петь()

# ======================================================================

### 13
# АБСТРАКТНЫЕ КЛАССЫ - задают общую структуру поведения для подклассов,
#                       но сами не предназначены для непосредственного
#                       инстанцирования. Интерфейсы определяют набор
#                       обязательных методов, которые должны быть реализованы
#                       в дочерних классах.
from abc import ABC, abstractmethod

class Транспорт(ABC):
    @abstractmethod
    def поехать(self):
        pass

class Велосипед(Транспорт):
    def поехать(self):
        print('Еду на велосипеде!')

# ======================================================================

### 14
# КОМПОЗИЦИЯ — отношение между объектами, когда один объект содержит другие
#               объекты в качестве компонентов. Это позволяет создавать
#               сложные структуры путем объединения простых элементов.
class Колесо:
    def вращаться(self):
        print('Колесо крутится.')

class Автомобиль:
    def __init__(self):
        self.круглые_части = [Колесо() for _ in range(4)]

    def ехать(self):
        for колесо in self.круглые_части:
            колесо.вращаться()

# ======================================================================

### 15
# ДЕКОРАТОРЫ КЛАССОВ - позволяют изменять поведение классов динамически,
#                      не затрагивая исходный код. Например, декоратор может
#                      добавить возможность журналирования действий объекта.
def log_class(cls):
    class WrapperClass(cls):
        def __init__(self, *args, **kwargs):
            super().__init__(*args, **kwargs)
            print(f'Создан новый {cls.__name__}')
    return WrapperClass

@log_class
class Самолет:
    def взлететь(self):
        print('Самолет взлетел!')

# ======================================================================

### 16
# ИТЕРАЦИИ И ГЕНЕРАЦИИ - Можно сделать объекты класса итерируемыми,
#                          чтобы их элементы могли перебираться циклом for.
#                          Это удобно для коллекций данных.
class Цифры:
    def __init__(self, max_value):
        self.max_value = max_value
        self.current = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.current >= self.max_value:
            raise StopIteration
        result = self.current
        self.current += 1
        return result

# ======================================================================

### 17
# Mixin-класс — небольшой класс, предназначенный для добавления
#                 функциональности другим классам посредством
#                 множественного наследования. Такие классы часто
#                 используются для повторного использования небольших
#                 фрагментов функционала.
class FlyableMixin:
    def полететь(self):
        print('Взлетаю!')

class ЛетающийАвтомобиль(FlyableMixin):
    def двигаться(self):
        print('Передвигаюсь по земле.')

# ======================================================================

### 18
# ПОДСТАНОВОЧНЫЕ ИМЕНА (*args, **kwargs) - При определении методов
#                        иногда полезно передавать произвольное количество
#                        аргументов. Аргументы могут передаваться
#                        позиционно (*args) или именованно (**kwargs).
class Магазин:
    def купить(self, *товары):
        for товар in товары:
            print(f'Купил {товар}.')

# ======================================================================

### 19
# ПЕРЕГРУЗКА ОПЕРАТОРОВ - позволяет определять собственное поведение
#                           встроенных операторов вроде +, ==, <, > и др.,
#                           применительно к вашим объектам.
#                           Благодаря этому ваши объекты могут вести себя
#                           естественным образом при выполнении
#                           различных операций.
class КомплексноеЧисло:
    def __init__(self, real=0, imag=0):
        self.real = real
        self.imag = imag

    def __add__(self, other):
        new_real = self.real + other.real
        new_imag = self.imag + other.imag
        return КомплексноеЧисло(new_real, new_imag)

    def __str__(self):
        return f"{self.real}+{self.imag}i"

a = КомплексноеЧисло(1, 2)
b = КомплексноеЧисло(3, 4)
c = a + b
print(c)  # выведет: 4+6i

# ======================================================================

### 20
# КОНТЕКСТНЫЕ МЕНЕДЖЕРЫ (with) - обеспечивают удобное управление ресурсами,
#                        такими как файлы, соединения с базой данных
#                        и прочие внешние ресурсы. Вы можете реализовать
#                        собственный менеджер контекста, определив
#                        специальные методы __enter__ и __exit__.
class ОткрывательФайлов:
    def __init__(self, filename):
        self.filename = filename

    def __enter__(self):
        self.file = open(self.filename, 'w')
        return self.file

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.file:
            self.file.close()

with ОткрывательФайлов('example.txt') as file:
    file.write('Привет, мир!')

# ======================================================================

### 21
# ОДИНОЧКИ (Singletons) - паттерн проектирования, обеспечивающий наличие
#                       единственного экземпляра определенного класса.
#                       Этот шаблон полезен, когда нужно гарантировать
#                       существование лишь одной копии объекта
#                       (например, конфигурационный файл или журнал ошибок).
class Конфигурация:
    _instance = None

    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super().__new__(cls)
        return cls._instance

config1 = Конфигурация()
config2 = Конфигурация()

print(config1 is config2)  # True

# ======================================================================

### 22
# ОБРАБОТКА ИСКЛЮЧЕНИЙ - важная часть обработки ошибок в программах.
#                          Определённые исключения можно ловить и
#                          обрабатывать в ваших собственных классах,
#                          делая программу устойчивее к ошибкам.
class БанковскийСчёт:
    def __init__(self, баланс=0):
        self.баланс = баланс

    def снять_деньги(self, сумма):
        try:
            if сумма > self.баланс:
                raise ValueError("Недостаточно денег на счёте.")
            self.баланс -= сумма
        except ValueError as e:
            print(e)

account = БанковскийСчёт(100)
account.снять_деньги(200)  # Недостаточно денег на счете.

# ======================================================================

### 23
# ЗАМЫКАНИЯ - это функции, сохраняющие окружающие их переменные
#               даже после завершения внешней функции.
def create_counter(start=0):
    count = start
    def increment():
        nonlocal count
        count += 1
        return count
    return increment

counter = create_counter(10)
print(counter())  # выводит 11

# ======================================================================

### 24
# ФАБРИКИ КЛАССОВ - это функции, создающие новые классы динамически.
def make_class(name, fields):
    attrs = {'__slots__': tuple(fields)}
    return type(name, (), attrs)

MyClass = make_class('MyClass', ['x', 'y'])
obj = MyClass()
obj.x = 10
obj.y = 20

# ======================================================================

### 25
# МЕТАКЛАССЫ - это класс, порождающий другие классы. Обычные классы
#               являются экземплярами метакласса type. Изменяя метакласс,
#               можно влиять на процесс создания новых классов.
class UppercaseMeta(type):
    def __new__(meta, name, bases, namespace):
        uppercase_namespace = {
            attr_name.upper(): attr_value
            for attr_name, attr_value in namespace.items()
        }
        return super().__new__(meta, name, bases, uppercase_namespace)

class MyClass(metaclass=UppercaseMeta):
    x = 10

print(MyClass.X)  # 10

# ======================================================================

### 26
# РЕАЛИЗАЦИЯ - __getattr__, __setattr__, __delattr__
#               Эти специальные методы управляют поведением при доступе
#               к атрибутам, установке атрибутов и удалении атрибутов
#               соответственно. Это полезно, когда нужно отслеживать
#               изменения атрибутов или организовать обработку
#               отсутствующих атрибутов.
class ProxyObject:
    def __init__(self, obj):
        self.obj = obj

    def __getattr__(self, item):
        return getattr(self.obj, item)

    def __setattr__(self, key, value):
        if key != 'obj':
            setattr(self.obj, key, value)
        else:
            object.__setattr__(self, key, value)

class Person:
    def __init__(self, name):
        self.name = name

p = Person('Иван')
proxy = ProxyObject(p)
proxy.name = 'Петя'
print(proxy.name)  # Петя

# ======================================================================

### 27
# АВТОМАТИЧЕСКОЕ СОЗДАНИЕ СВОЙСТВ С ПОМОЩЬЮ ДЕСКРИПТОРА
#                   Дескрипторы — это объекты, определяющие протокол
#                   управления доступом к атрибутам.
#                   Позволяют автоматизировать рутинные задачи вроде
#                   проверки ввода, кэширование вычислений
#                   и многое другое.
class NonNegative:
    def __set_name__(self, owner, name):
        self.private_name = '_' + name

    def __get__(self, instance, owner):
        return getattr(instance, self.private_name)

    def __set__(self, instance, value):
        if value < 0:
            raise ValueError("Значение должно быть неотрицательным.")
        setattr(instance, self.private_name, value)

class Worker:
    salary = NonNegative()

worker = Worker()
worker.salary = 1000
print(worker.salary)  # 1000
worker.salary = -100  # поднимет исключение ValueError

# ======================================================================

### 28
# ИНТРОСПЕКЦИЯ И ОТРАЖЕНИЕ - Интроспекция — это
#                   возможность исследовать внутренние свойства объектов
#                   и классов прямо во время исполнения программы.
#                   Используются функции dir(),
#                                        hasattr(),
#                                        getattr(),
#                                        isinstance()
#                                        и другие.
class Animal:
    species = 'mammal'

animal = Animal()
print(dir(animal))       # вывод списка всех атрибутов и методов объекта
print(hasattr(animal, 'species'))  # проверяет наличие атрибута

# ======================================================================

### 29
# ПРОСТРАНСТВА ИМЁН И ОБЛАСТИ ВИДИМОСТИ
#                   Каждый класс имеет свое пространство имен,
#                   в котором хранятся его собственные атрибуты и методы.
#               NB! Важно помнить, как устроены пространства имен,
#                   чтобы правильно управлять видимостью и избегать конфликтов
#                   имен.
class Outer:
    var_outer = 'Outer variable'

    class Inner:
        var_inner = 'Inner variable'

print(Outer.var_outer)     # Output: Outer variable
print(Outer.Inner.var_inner)  # Output: Inner variable

# ======================================================================

### 30
# ПРОВЕРКА ТИПОВ АННОТАЦИИ
# Начиная с версии Python 3.5 появилась поддержка аннотаций типов,
#                           позволяющих документировать типы аргументов
#                           и возвращаемых значений функций и методов.
#                           Хотя проверка типов выполняется динамически,
#                           аннотации помогают разработчикам писать
#                           ясный и читаемый код.
class User:
    def __init__(self, name: str):
        self.name = name

    def greet(self) -> str:
        return f"Привет, {self.name}"

u = User("Анна")
print(u.greet())

# ======================================================================

### 31
# ПРОТОКОЛЫ И duck typing
# Протоколы  —  это соглашения о наличии определенных методов и атрибутов
#               у объекта, позволяющие разным объектам взаимодействовать
#               друг с другом независимо от их иерархии классов.
#               Duck typing ("принцип утенка") гласит:
#               "Если объект ведет себя как утка
#               (имеет необходимые методы и атрибуты),
#               значит, это утка."
class Counter:
    def __init__(self, low, high):
        self.low = low
        self.high = high

    def __iter__(self):
        current = self.low
        while current <= self.high:
            yield current
            current += 1

for num in Counter(1, 5):
    print(num)

# ======================================================================

### 32
# ИММУТАБЕЛЬНОСТЬ
# Иммутабельные объекты — это объекты, значения которых нельзя менять
#                       после создания. Стандартные иммутабельные типы
#                       включают числа, строки, кортежи и замороженные
#                       множества. Создаваемые классы также могут быть
#                       сделаны иммутабельными.
class ImmutablePoint:
    __slots__ = ('x', 'y')

    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __hash__(self):
        return hash((self.x, self.y))

point = ImmutablePoint(1, 2)
try:
    point.x = 3  # выдаст ошибку AttributeError
except AttributeError as e:
    print(e)

# ======================================================================

### 33
# СЛОТЫ (__slots__)
#           Использование слотов ограничивает набор атрибутов,
#           разрешенных в классе, и повышает производительность
#           благодаря уменьшению потребления памяти. Без использования
#           слотов каждое свойство объекта хранится в словаре (__dict__),
#           что требует большего объема памяти.
class Point:
    __slots__ = ('x', 'y')

    def __init__(self, x, y):
        self.x = x
        self.y = y

point = Point(1, 2)
try:
    point.z = 3  # ошибка AttributeError
except AttributeError as e:
    print(e)

# ======================================================================

### 34
# МОДУЛИ И ПАКЕТЫ
# Модуль — это отдельный файл с расширением .py, содержащий
#           определение классов, функций и переменных.
# Пакеты — это каталоги, содержащие модули
#           и дополнительный файл __init__.py.
#           Организация вашего проекта с использованием модулей и пакетов
#           улучшает структуру кода и облегчает повторное
#           использование компонентов.

#---# Пример модуля:
# module.py
class Calculator:
    def add(self, a, b):
        return a + b

#---# Используем модуль:
import module
calc = module.Calculator()
result = calc.add(2, 3)
print(result)  # 5

# ======================================================================

### 35
# ОПТИМИЗАЦИЯ ПРОИЗВОДИТЕЛЬНОСТИ
# Оптимизация классов важна, особенно при работе с большими объемами
#                           данных или сложных структурах. Основные
#                           приемы оптимизации включают минимизацию
#                           количества обращений к атрибутам,
#                           использование локальных переменных и
#                           оптимизированных алгоритмов.
class OptimizedLoop:
    def process_data(self, data):
        size = len(data)
        local_sum = sum(data[:size//2])
        return local_sum

# ======================================================================









Экземпляр объекта
Декоратор