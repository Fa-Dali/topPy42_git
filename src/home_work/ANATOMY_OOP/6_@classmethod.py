# 6_@classmethod.py

'''
Представь, что у тебя есть любимая коллекция игрушек — например, машинки.
Машины одной марки похожи друг на друга: у них одинаковые колеса, фары,
руль и многое другое. Это общий шаблон для всех машин данной марки, верно?

Теперь представь, что тебе нужно сказать всем машинам одного бренда:
"Покажи, какая у тебя максимальная скорость." Обычно для этого пришлось бы
спросить каждую машину индивидуально, ведь у каждой своя собственная скорость.
Но это долго и неудобно.

Тут на помощь приходят **методы класса**! Это особые методы, которые относятся
не к отдельной машине, а к целой марке машин. Такие методы понимают, что они
принадлежат не одному автомобилю, а сразу всей группе похожих машин.

Другими словами, **методы класса** действуют
на уровне **всех объектов класса**, а не на каком-то одном конкретном объекте.
----------------------------------
### Подробности простыми словами:
- **Методы класса** помечены специальным знаком `@classmethod`.
Это сигнализирует Python, что метод принадлежит всему классу целиком,
а не отдельному объекту.

- Первым аргументом в методе класса всегда идет специальная переменная `cls`,
которая представляет собой сам класс. Именно через нее мы получаем доступ к
общим характеристикам и параметрам класса.

- **Зачем нужны методы класса?**

  Во-первых, они позволяют управлять поведением всех объектов класса разом.
  Например, считать общее количество созданных объектов, установить
  какое-нибудь единое свойство для всех объектов или вернуть особый объект
  класса (это называется фабрика объектов).

  Во-вторых, методы класса можно использовать для работы с классовыми
  атрибутами — теми, что определены в самом классе, а не в объектах.
  Например, подсчет количества созданных объектов.

### Примеры использования методов класса:

#### 1️⃣ Считаем общее количество объектов класса

    Допустим, у нас есть класс `Cat`, и мы хотим отслеживать,
    сколько кошек создано:
'''
class Cat:
    total_count = 0  # Общий счётчик кошек

    def __init__(self, name):
        self.name = name
        Cat.total_count += 1  # Увеличим счётчик при создании кота

    @classmethod
    def show_total_count(cls):
        print(f"Всего котов: {cls.total_count}")

kitty = Cat("Барсик")
muffin = Cat("Муффин")

Cat.show_total_count()  # Всего котов: 2
'''

#### 2️⃣ Фактория объектов (класс-метод как конструктор)
    Иногда хочется создать объект особым образом, используя дополнительный 
    аргумент или условие. Здесь метод класса идеален:
'''
class Fraction:
    def __init__(self, numerator, denominator):
        self.numerator = numerator
        self.denominator = denominator

    @classmethod
    def from_decimal(cls, decimal_number):
        numerator = decimal_number.as_integer_ratio()[0]
        denominator = decimal_number.as_integer_ratio()[1]
        return cls(numerator, denominator)

fraction = Fraction.from_decimal(0.5)
print(fraction.numerator, fraction.denominator)  # выведет: 1 2
'''

### Ещё немного теории:

Методы класса отличаются от обычных методов следующим:
- Обычный метод действует на отдельный объект и получает аргумент `self`, 
        означающий сам объект.
- Метод класса действует на весь класс и получает аргумент `cls`, 
        означающий сам класс.

### Итак, подведём итоги:

- **Методы класса** работают на уровне всего класса, а не отдельного объекта.
- Они получают первым аргументом класс (`cls`), а не объект (`self`).
- Применяются для операций, влияющих на весь класс или возвращающих объекты 
        класса особым образом.

Да, помимо основного материала, есть несколько полезных советов и тонкостей, 
связанных с методами класса в Python. Расскажу о них подробнее.

=====================================================
### Тонкости и хитрости использования методов класса:
=====================================================

#### 1. **Передача дополнительного контекста через аргументы метода класса**

Методы класса могут принимать произвольные аргументы, 
помимо обязательного `cls`. 
Это открывает широкие возможности для расширения функционала:

'''
class Factory:
    @classmethod
    def create_with_default_values(cls, default_value):
        return cls(default_value)

class Product(Factory):
    def __init__(self, initial_value):
        self.value = initial_value

product = Product.create_with_default_values(100)
print(product.value)  # 100
'''
Здесь мы передали дополнительное значение в метод класса, которое 
использовалось для инициализации объекта.

#### 2. **Наследование и переопределение методов класса**

Производные классы могут переопределять методы класса, сохранив оригинальное 
поведение родительского класса. Используя суперкласс, можно избежать 
повторного объявления метода.

'''
class Parent:
    @classmethod
    def parent_method(cls):
        print("Родительский метод")

class Child(Parent):
    @classmethod
    def child_method(cls):
        super().parent_method()
        print("Детский метод")

Child.child_method()  # Родительский метод\nДетский метод
'''

#### 3. **Строгая зависимость от структуры класса**

Методы класса жестко завязаны на структуре и специфике класса. 
Изменения в классе могут повлиять на работу методов класса. 
Будьте осторожны при рефакторинге классов, проверяйте совместимость 
всех зависимых методов.

#### 4. **Использование мета-классов для контроля методов класса**

Мета-классы позволяют управлять процессом создания классов и методом класса, 
например, проверять их правильность или вводить дополнительную логику.

'''
class Meta(type):
    def __new__(meta, name, bases, namespace):
        if 'create_object' not in namespace:
            raise TypeError("Необходимо определить метод create_object")
        return super().__new__(meta, name, bases, namespace)

class ClassWithMethod(metaclass=Meta):
    @classmethod
    def create_object(cls):
        return cls()
'''

#### 5. **Преобразование обычного метода в метод класса**

Для перехода от обычного метода экземпляра к методу класса вы можете 
воспользоваться изменением сигнатуры и добавлением декоратора `@classmethod`.

'''
class Example:
    def normal_method(self):
        print("Нормальный метод")

    @classmethod
    def class_method(cls):
        print("Метод класса")

example = Example()
Example.class_method()  # Метод класса
'''

#### 6. **Применение к структурам данных**

Методы класса можно успешно применять в работе с контейнерами и коллекциями, 
помогая автоматизировать рутинные операции:

'''
class Collection:
    items = []

    @classmethod
    def append_item(cls, item):
        cls.items.append(item)

Collection.append_item("Элемент 1")
Collection.append_item("Элемент 2")
print(Collection.items)  # ['Элемент 1', 'Элемент 2']
'''

#### 7. **Оптимизация и кэширование результатов**

Используйте кэширование результатов сложных вычислений, выполняемых методами 
класса, чтобы ускорить повторные запросы.

'''
import functools

class CacheHelper:
    @classmethod
    @functools.lru_cache(maxsize=None)
    def expensive_computation(cls, arg):
        # Симуляция сложной операции
        result = arg * 2
        return result

CacheHelper.expensive_computation(10)  # Первое вычисление займёт время
CacheHelper.expensive_computation(10)  # Второе быстрое,
                                        # так как результат взят из кеша
'''

### Ключевые моменты для запоминания:

- Методы класса фиксируются на уровне класса и могут применяться к любому 
        объекту этого класса.
- Декораторами `@classmethod` отмечаются методы, работающие с самим классом, 
        а не с экземпляром.
- Используйте методы класса для централизованного управления общими 
        действиями и ресурсами.

======================================================
Есть еще несколько тонких моментов и полезных приемов, 
связанных с методами класса в Python. Продолжим изучать тему чуть глубже.
======================================================

### Дополнительно о методах класса:

#### 1. **Изменение поведения методов класса при помощи декоратора**

Один из способов расширить функциональность методов класса 
        — использовать кастомные декораторы. Так можно добавить 
          логирование, проверку прав доступа или другие полезные механизмы.

'''
def log_class_method(func):
    def wrapper(*args, **kwargs):
        print(f"Логируем вызов метода класса: {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

class Logger:
    @log_class_method
    @classmethod
    def log_message(cls, message):
        print(message)

Logger.log_message("Сообщение журнала")  # Логируем вызов метода класса:
                                            # log_message\nСообщение журнала
'''

#### 2. **Самостоятельная реализация фабричного метода**

Фактически, методы класса широко применяются в реализации шаблона 
проектирования "Фабричный метод". Фабрики позволяют создавать объекты с 
различным поведением, основываясь на общем интерфейсе.

'''
class Creator:
    @classmethod
    def factory_method(cls):
        return cls()

class ConcreteCreator(Creator):
    def do_work(self):
        print("Выполняем конкретную работу")

creator = ConcreteCreator.factory_method()
creator.do_work()  # Выполняем конкретную работу
'''

#### 3. **Управление жизненным циклом классов**

Методы класса могут использоваться для автоматической очистки ресурсов или 
завершения операций при завершении жизни объекта.

'''
class ResourceHandler:
    resources = {}

    @classmethod
    def register_resource(cls, resource_id, resource):
        cls.resources[resource_id] = resource

    @classmethod
    def cleanup_resources(cls):
        cls.resources.clear()

ResourceHandler.register_resource(1, "file.txt")
ResourceHandler.cleanup_resources()  # очищает ресурсы
'''

#### 4. **Взаимодействие с системой типов (typing)**

Методы класса хорошо работают с системами типизации, что помогает 
удостовериться в правильности использования метода.

'''
from typing import List

class DataStorage:
    storage: List[str] = []

    @classmethod
    def store_data(cls, data: str):
        cls.storage.append(data)

DataStorage.store_data("Данные 1")
DataStorage.store_data("Данные 2")
'''

#### 5. **Пространство имен и импортирование**

Будьте внимательны при импорте модулей, содержащих методы класса. 
При прямом импорте модуля пространство имен может конфликтовать, 
если одноименный метод определен в другом месте.

'''
from module import ClassName

ClassName.class_method()  # Импортируем метод класса из другого модуля
'''

#### 6. **Комбинация с менеджерами контекста**

Методы класса могут выступать в роли менеджеров контекста, устанавливая 
требуемые настройки и освобождая ресурсы по окончании блока.

'''
class ContextManager:
    @classmethod
    def __enter__(cls):
        print("Начало контекста")

    @classmethod
    def __exit__(cls, exc_type, exc_val, exc_tb):
        print("Завершение контекста")

with ContextManager():
    print("Рабочий блок")  # Начало контекста\nРабочий блок\nЗавершение контекста
'''

#### 7. **Аннотирование типов и поддержка IDE**

Современные среды разработки (IDE) поддерживают аннотации типов, что улучшает 
навигацию и автодополнение. Правильная аннотация позволит вашему коду быть 
более понятным и предсказуемым.

'''
class Document:
    @classmethod
    def generate_document(cls, content: str) -> str:
        return f"Генерируем документ: {content}"
'''

### Несколько советов по применению методов класса:

- Старайтесь использовать методы класса, когда логика касается уровня класса, 
        а не отдельного объекта.
- Пишите документацию для методов класса, чтобы коллегам и будущим 
        разработчикам было легче разобраться в вашем коде.
- Регулярно обновляйте тесты, если изменяете логику методов класса, 
        чтобы убедиться в работоспособности вашего кода.

Эти советы и подходы помогут вам писать качественный и эффективный код с 
использованием методов класса в Python. Продолжайте совершенствовать свои 
знания и экспериментируйте с новыми возможностями!
'''