### 13
# АБСТРАКТНЫЕ КЛАССЫ - задают общую структуру поведения для подклассов,
#                       но сами не предназначены для непосредственного
#                       инстанцирования. Интерфейсы определяют набор
#                       обязательных методов, которые должны быть реализованы
#                       в дочерних классах.


'''
Представь себе ситуацию, когда мама просит тебя нарисовать животное.
Ты задаёшь ей уточняющий вопрос: «Какое именно?» Ведь животные бывают
разные — кошки, собаки, слоны... А мама отвечает: «Просто нарисуй
абстрактное животное». Что же тогда рисовать?

Абстрактное животное — это такое понятие, которое объединяет всех животных
сразу, но само по себе отдельно не существует. Это общий образ животного
вообще, но конкретного существа («собака», «кошка») оно не обозначает.

То же самое и с абстрактными классами в Python! Они представляют собой общие
идеи, которые объединяют разные объекты, но сами по себе ничего не делают
конкретно. Например, у нас есть классы `Собака`, `Кошка` и другие. Мы можем
создать ещё один класс, скажем, `Животное`. Этот класс станет абстрактным,
потому что сам по себе никакое отдельное живое существо не представляет,
зато объединяет все конкретные классы (`Собака`, `Кошка`) и помогает задать
правила поведения и свойства, которыми обладают все животные сразу.

Вот такой вот упрощённый пример, чтобы стало понятнее!

---

Теперь подробнее простыми словами:

**Абстрактный класс** — это шаблон или идея, которой следуют другие классы.
Сам по себе этот класс не используется для создания объектов, но служит
основой для конкретных классов. Например, класс `Транспорт` может быть
абстрактным, ведь транспорт бывает разный: автомобиль, самолёт, поезд…
Но мы не можем представить объект типа «просто транспорт».

Таким образом, **абстрактный класс** нужен, чтобы:
- Установить общую структуру и поведение для разных типов объектов.
- Облегчить создание новых классов, поскольку всё нужное уже прописано заранее.

Это как чертеж дома: по нему строят конкретный дом, но сам чертёж никто не
живёт.

Итак, подведём итог:
- Абстрактный класс — это общая концепция, которую нельзя использовать
        самостоятельно.
- Он определяет базовую структуру и правила для других классов.

- Конкретные классы наследуются от абстрактного класса и получают нужные
        методы и свойства.

Давай разберем пару простых примеров на Python, чтобы лучше понять работу
абстрактных классов.

### Пример №1: Животные

Создадим абстрактный класс `Animal`, от которого будут наследоваться
конкретные виды животных (`Dog`, `Cat`).

'''
from abc import ABC, abstractmethod

# Создаем абстрактный класс Animal
class Animal(ABC):
    # Абстрактный метод eat()
    @abstractmethod
    def eat(self):
        pass

    # Абстрактный метод sound()
    @abstractmethod
    def sound(self):
        pass


# Класс Dog наследуется от Animal
class Dog(Animal):
    def eat(self):
        print("Собака ест косточку.")

    def sound(self):
        print("Собака гавкает!")


# Класс Cat также наследуется от Animal
class Cat(Animal):
    def eat(self):
        print("Кошка ест рыбу.")

    def sound(self):
        print("Кошка мяукает!")
'''

Что тут произошло:
- Мы создали абстрактный класс `Animal`.

- Внутри этого класса определены два метода: `eat()` и `sound()`, помеченные
        декоратором `@abstractmethod`. Эти методы обязательны для реализации 
        в любых дочерних классах.
- Затем создали два конкретных класса: `Dog` и `Cat`, которые унаследовали 
        методы от абстрактного класса и реализовали их по-своему.

### Пример №2: Геометрические фигуры

Ещё один простой пример — геометрические фигуры. Пусть у нас будет абстрактный 
класс `Shape`, от которого будут зависеть конкретные формы 
(`Circle`, `Rectangle`).

'''
from abc import ABC, abstractmethod

# Абстрактный класс Shape
class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

    @abstractmethod
    def perimeter(self):
        pass


# Класс Circle наследует от Shape
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14 * self.radius ** 2

    def perimeter(self):
        return 2 * 3.14 * self.radius


# Класс Rectangle тоже наследует от Shape
class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

    def perimeter(self):
        return 2 * (self.width + self.height)
'''

Здесь:
- Есть абстрактный класс `Shape`, определяющий две ключевые характеристики 
        фигур: площадь (`area`) и периметр (`perimeter`).
- Два конкретных класса: круг (`Circle`) и прямоугольник (`Rectangle`), 
        каждый из которых реализует свою собственную версию методов площади 
        и периметра.


Эти примеры показывают, как работают абстрактные классы и почему они полезны. 
Надеюсь, теперь ясно!

Нет, нельзя прямо внутри абстрактного метода давать какую-то реализацию, 
такую как вычисления или присваивания переменных, как показано в твоём примере:

'''
b = 0
c = 0

class Shape(ABC):
    @abstractmethod
    def area(self):
        a = b * c
'''

Причина проста: абстрактный метод предназначен лишь для объявления интерфейса, 
который обязательно должны реализовать подклассы. То есть он говорит другим 
классам: «Вы обязаны определить метод с таким названием и сигнатурой!» 
Если бы там была какая-то реализация, это нарушило бы смысл абстракции.

Другими словами, абстрактный метод обязан оставаться пустым (например, 
содержать ключевое слово `pass`), иначе теряется вся суть абстрактного класса.

Но если хочется, чтобы какой-то стандартный алгоритм присутствовал в классе, 
его можно сделать обычным методом, не абстрактным. Тогда подклассы смогут его 
переопределять или дополнять. Однако важно помнить, что такие методы не 
являются обязательными для реализации.

Пример правильного подхода с реализацией по умолчанию:

'''
from abc import ABC, abstractmethod

class Shape(ABC):
    # Обычный метод, доступный для переопределения
    def area(self):
        raise NotImplementedError("Метод area() должен быть "
                                  "реализован в подклассах")

    # Другой обычный метод, возможно полезный для всех фигур
    def double_area(self):
        return 2 * self.area()

# Теперь любой подкласс может либо оставить default-метод area(),
# либо переписать его
'''

Или другой вариант:

'''
from abc import ABC, abstractmethod

class Shape(ABC):
    # Метод по умолчанию, позволяющий расширить функциональность
    def area(self):
        return None  # Или какое-нибудь значение по умолчанию

    # Реализация другого метода, использующего предыдущий
    def double_area(self):
        if self.area():
            return 2 * self.area()
        else:
            return "Площадь не определена."

# Подкласс имеет возможность переопределить или оставить как есть
'''

Так что можешь спокойно оставлять абстрактные методы пустыми и заставлять 
потомков классов думать над своей собственной реализацией!

=======================================================================
ХИТРОСТИ ОСОБЕННОСТИ И ТОНКОСТИ
=======================================================================

Применение абстрактных классов в Python — дело весьма гибкое и мощное, 
но имеющее ряд особенностей и нюансов. Рассмотрим каждую деталь с примерами:

## 1. Абстрактность означает обязательное переопределение
Любой метод, отмеченный декоратором `@abstractmethod`, должен быть реализован 
всеми подклассами, которые наследуются от абстрактного класса. Если этого не 
сделать, попытка создать экземпляр подкласса приведет к ошибке.

**Пример**:
Допустим, у вас есть абстрактный класс `Vehicle` с абстрактным методом 
`start_engine()`:
'''
from abc import ABC, abstractmethod

class Vehicle(ABC):
    @abstractmethod
    def start_engine(self):
        pass

class Car(Vehicle):
    def start_engine(self):
        print("Автомобиль завёлся.")

car = Car()
car.start_engine()  # Всё работает нормально

truck = Vehicle()   # Приведет к ошибке,
                    # так как нельзя создать экземпляр абстрактного класса
'''

## 2. Можно иметь смесь абстрактных и обычных методов
Класс, помеченный как абстрактный, может содержать как абстрактные методы 
(обязательно реализуемые), так и обычные методы с полной реализацией. 
Так вы сможете одновременно диктовать стандарты для подклассов и предложить 
удобную встроенную функциональность.

**Пример**:
Давайте расширим наш класс транспортных средств, добавив обычную реализацию 
метода `stop_engine()`:
'''
class Vehicle(ABC):
    @abstractmethod
    def start_engine(self):
        pass

    def stop_engine(self):
        print("Двигатель остановлен.")

class Car(Vehicle):
    def start_engine(self):
        print("Автомобиль завёлся.")

car = Car()
car.stop_engine()  # Работает даже без отдельной реализации в подклассе
'''

## 3. Невозможно создавать экземпляры абстрактных классов
Абстрактный класс не предназначен для прямого создания экземпляров. 
Любая попытка вызвать конструктор абстрактного класса приведёт к ошибке. 
Поэтому убедитесь, что ваш код правильно обрабатывает попытки пользователей 
случайно инициировать абстрактный класс.

**Пример**:
Рассмотрим попытку создать экземпляр абстрактного класса `Vehicle`:
'''
try:
    vehicle = Vehicle()  # Ошибка TypeError
except Exception as e:
    print(e)
'''
Результат будет примерно следующим:

`"Can't instantiate abstract class Vehicle with abstract methods start_engine"`

Невозможно создать экземпляр абстрактного класса Vehicle с абстрактными 
методами start_engine

## 4. Использование множественного наследования с абстрактными классами
Python поддерживает множественное наследование, включая применение нескольких
абстрактных классов. Будьте внимательны к конфликтам между методами разных
родительских классов. Порядок наследования играет важную роль в разрешении
конфликтов.

**Пример**:
Предположим, у нас есть два абстрактных класса: `ElectricDevice` и
`EnginePoweredDevice`, оба требуют реализации метода `turn_on()`. Если у
подкласса возникнут проблемы с определением приоритетов, придётся аккуратно
управлять порядком наследования.
'''
class ElectricDevice(ABC):
    @abstractmethod
    def turn_on(self):
        pass

class EnginePoweredDevice(ABC):
    @abstractmethod
    def turn_on(self):
        pass

class HybridCar(ElectricDevice, EnginePoweredDevice):
    def turn_on(self):
        print("Hybrid car is on.")  # Конфликт разрешен вручную
'''

## 5. Совместимость с модульной структурой проекта
Абстрактные классы прекрасно подходят для крупных проектов, где различные 
модули создаются независимо друг от друга. Используя абстрактные классы, 
вы устанавливаете четкий стандарт, которому должны следовать разработчики.

**Пример**:
Пусть ваша команда разработчиков пишет систему управления устройствами, 
состоящую из множества модулей. Один из них отвечает за управление светом, 
другой — за климат-контроль. Используя абстрактный класс `DeviceManager`, 
вы обеспечиваете единый интерфейс взаимодействия с любыми устройствами:
'''
class DeviceManager(ABC):
    @abstractmethod
    def connect_device(self):
        pass

    @abstractmethod
    def disconnect_device(self):
        pass

class LightController(DeviceManager):
    def connect_device(self):
        print("Подключили свет.")

    def disconnect_device(self):
        print("Отключили свет.")
'''

## 6. Переход от обычного класса к абстрактному
Преобразование существующего класса в абстрактный выполняется добавлением 
декоратора `@abstractmethod` и импортом модуля `abc`. Будьте готовы к тому, 
что пользователям придется адаптировать свой код, чтобы учесть новые 
требования.

**Пример**:
Имеющийся класс `DatabaseConnector` превращается в абстрактный класс с 
обязательным методом подключения:
'''
import abc

class DatabaseConnector(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def connect(self):
        pass

class MySQLConnector(DatabaseConnector):
    def connect(self):
        print("Подключение к MySQL выполнено.")
'''

## 7. Ошибки из-за неправильного переопределения абстрактных методов
Одна из частых ошибок связана с неправильным переопределением абстрактных 
методов. Нужно внимательно проверять название и количество аргументов 
каждого переопределённого метода. Даже малейшее отклонение от оригинала 
приведет к сбою.

**Пример**:
Неправильное переопределение метода вызывает ошибку:
'''
class Vehicle(ABC):
    @abstractmethod
    def start_engine(self):
        pass

class BrokenCar(Vehicle):
    def start_engine_with_key(self):  # Имя отличается, приводя к ошибке
        print("Завели машину ключом.")

broken_car = BrokenCar()  # Ошибка, так как не переопределён start_engine()
'''

## Хитрость: Смешивание миксин-классов с абстрактными классами
Миксин-классы — это удобный способ добавления дополнительной функциональности 
к вашим классам. Их можно комбинировать с абстрактными классами, создавая 
гибкую архитектуру. Миксины добавляют небольшие полезные фрагменты 
функционала, не нарушая основную структуру ваших классов.

**Пример**:
Представьте, что у вас есть миксин-класс `LoggableMixin`, предоставляющий 
простейшую запись действий в журнал:
'''
class LoggableMixin:
    def log_action(self, action):
        print(f"{action} logged.")

class User(LoggableMixin):
    def login(self):
        self.log_action("Login")  # Используем миксин для ведения журнала

user = User()
user.login()  # Результат: Login logged.
'''

Правильно применяя абстрактные классы, вы получите мощный инструмент для 
организации своего кода и построения надежной архитектуры приложений. 
Главное — сохранять внимание к деталям и придерживаться разумного баланса 
между строгостью требований и гибкостью решений.

======================================================================
МЕБЕЛЬНОЕ ПРОИЗВОДСТВО
======================================================================
Приведу десять абстрактных классов, используемых в мебельном производстве, 
используя русские названия классов, методов и переменных.


### 1. Основная фабрика мебели
Абстрактный класс для общего процесса производства мебели.

'''
from abc import ABC, abstractmethod

class ФабрикМебели(ABC):
    @abstractmethod
    def изготовитьСтул(self):
        pass

    @abstractmethod
    def изготовитьСтол(self):
        pass
'''

### 2. Деревообработка
Абстрактный класс для обработки древесины.

'''
class ДеревообрабатывающееПредприятие(ABC):
    @abstractmethod
    def обработатьДерево(self):
        pass

    @abstractmethod
    def собратьМебель(self):
        pass
'''

### 3. Мягкая мебель
Абстрактный класс для производства диванов, кресел и матрасов.

'''
class ЗаводМягкойМебели(ABC):
    @abstractmethod
    def пошивОбивки(self):
        pass

    @abstractmethod
    def набивкаПодушек(self):
        pass
'''

### 4. Производство кухонь
Абстрактный класс для сборки кухонных гарнитуров.

'''
class ЗаводКухонныхГарнитуров(ABC):
    @abstractmethod
    def раскройМатериалы(self):
        pass

    @abstractmethod
    def установкаФурнитуры(self):
        pass
'''

### 5. Корпусная мебель
Абстрактный класс для заводов, изготавливающих шкафы, комоды и полки.

'''
class ЗаводКорпуснойМебели(ABC):
    @abstractmethod
    def разработкаКонструкций(self):
        pass

    @abstractmethod
    def финишнаяОбработкаПоверхности(self):
        pass
'''

### 6. Офисная мебель
Абстрактный класс для предприятий, выпускающих столы, кресла и стеллажи для офисов.

'''
class ПредприятиеОфиснойМебели(ABC):
    @abstractmethod
    def изготовлениеРабочихСтолов(self):
        pass

    @abstractmethod
    def изготовлениеХранительныхЕдиниц(self):
        pass
'''

### 7. Ручная работа дизайнеров
Абстрактный класс для мастерских эксклюзивных авторских работ.

'''
class МастерскаяЭксклюзивнойМебели(ABC):
    @abstractmethod
    def эскизПроектирование(self):
        pass

    @abstractmethod
    def ручнаяРаботаНадПродуктом(self):
        pass
'''

### 8. Массовое производство кроватей
Абстрактный класс для заводского производства спальных мест.

'''
class ЗаводМатрасныхИСпальныхМест(ABC):
    @abstractmethod
    def сборкаКаркаса(self):
        pass

    @abstractmethod
    def монтажОснованияДляМатраса(self):
        pass
'''

### 9. Эко-мебель
Абстрактный класс для экологичных производств мебели.

'''
class ЭкоПроизводственникиМебели(ABC):
    @abstractmethod
    def использованиеПереработанныхМатериаллов(self):
        pass

    @abstractmethod
    def минимизацияОтходов(self):
        pass
'''

### 10. Детская мебель
Абстрактный класс для изготовления безопасной и привлекательной мебели 
для детей.

'''
class ЗаводДетскойМебели(ABC):
    @abstractmethod
    def обеспечениеБезопасностиРебенка(self):
        pass

    @abstractmethod
    def декорировкаИЦветовка(self):
        pass
'''

Эти примеры наглядно иллюстрируют использование абстрактных классов в 
мебельной индустрии, показывая, как каждая область производства может 
иметь собственный уникальный набор необходимых функций и обязанностей.
'''