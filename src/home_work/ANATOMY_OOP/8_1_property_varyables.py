'''
Getter (@имя.getter) — получает значение.
Setter (@имя.setter) — устанавливает значение, контролируя его правильность.
Deleter (@имя.deleter) — удаляет значение атрибута.

Когда мы объявляем свойство (через конструкцию @property),
оно становится доступным для чтения, но по умолчанию его
нельзя изменить напрямую. То есть:
'''

class МойДомашнийЛюбимец:
    @property
    def вес(self):
        return self._вес  # Видишь подчёркивание "_"?
                          # Оно значит, что само поле спрятано
                          # от прямого доступа.
'''
Здесь, если мы попытаемся поменять вес питомца:
'''
мой_котёнок = МойДомашнийЛюбимец()
мой_котёнок.вес = 5  # Ой-ой, ошибка возникнет!

'''
Почему возникает ошибка? Потому что изначально мы создали только метод 
для чтения веса (getter), но не указали правила для установки нового 
значения (setter).

*** @имя.setter ***

Используется, когда нужно назначить новому значению проверенное значение. 
Наш сеттер проверяет, что новый вес положителен, и только тогда 
обновляет внутренний атрибут.
    Именно тут и вступает в игру конструкция @рост.setter (точнее, 
в нашем случае это будет @вес.setter):
'''
class МойДомашнийЛюбимец:
    @property
    def вес(self):
        return self._вес

    @вес.setter
    def вес(self, новое_значение):
        if новое_значение > 0:
            self._вес = новое_значение
        else:
            raise ValueError("Вес не может быть отрицательным!")
'''
Теперь мы можем устанавливать правильный вес нашему питомцу, 
не боясь нарушить логику программы.

*** @имя.getter ***

НЕ ОБЯЗАТЕЛЬНО УКАЗЫВАТЬ ...читать далее --> 
Это метод, который вызывается всякий раз, когда запрашивается значение 
веса питомца. Например, когда мы пишем мой_котёнок.вес, 
вызывается именно геттер, который возвращает значение self._вес.
    Фактически тот самый метод, который возвращает значение (мы его уже 
видели раньше). Чаще всего его используют в сочетании с конструктором 
@property, поэтому отдельно указывать @имя.getter редко приходится.
...
*** @имя.deleter ***

Выполняется, когда мы пытаемся удалить значение атрибута. 
После выполнения del мой_котёнок.вес, внутренняя переменная _вес 
исчезает, и дальнейшие попытки прочитать вес вернут сообщение 
"Нет веса".
    Служит для удаления значения атрибута. Да-да, ты можешь удалить 
какое-то значение прямо из своего объекта, вызвав соответствующий метод. 
Очень редкая штука, но она есть!
'''
class МойДомашнийЛюбимец:
    def __init__(self, вес):
        self._вес = вес  # Внутренняя переменная, невидимая извне

    # Геттер: возвращает значение текущего веса
    @property
    def вес(self):
        print("Сейчас считываю вес...")
        return self._вес

    # Сеттер: контролирует установку нового значения веса
    @вес.setter
    def вес(self, новое_значение):
        if новое_значение > 0:
            print(f"Устанавливаю новый вес: {новое_значение}")
            self._вес = новое_значение
        else:
            raise ValueError("Вес не может быть отрицательным!")

    # Деалетер: удаляет внутреннее значение веса
    @вес.deleter
    def вес(self):
        print("Удаляю вес животного...")
        del self._вес

# Создаем питомца
мой_котёнок = МойДомашнийЛюбимец(5)

# Читаем вес питомца (геттер срабатывает)
print(f"Текущий вес моего любимца: {мой_котёнок.вес} кг")  # Здесь вызывается геттер

# Меняем вес питомца (сеттер сработает)
мой_котёнок.вес = 6
print(f"Нынешний вес: {мой_котёнок.вес} кг")  # Опять геттер прочитает вес

# Пробуем удалить вес питомца (деалетер)
del мой_котёнок.вес
print(getattr(мой_котёнок, '_вес', 'Нет веса'))  # Проверяем, остался ли
                                                 # внутренний вес

'''
--> @имя.getter ***
геттер указывать необязательно, поскольку при создании свойства 
с помощью декоратора @property подразумевается, 
что создается именно геттер (метод для чтения значения).

Рассмотрим это подробней:

Что происходит, когда используешь только @property?
Когда ты пишешь следующий код:
'''
class МойДомашнийЛюбимец:
    def __init__(self, вес):
        self._вес = вес

    @property
    def вес(self):
        return self._вес
'''
То есть фактически ты говоришь: "каждый раз, когда обращаются к атрибуту 
вес, вызвать этот метод". Ты автоматически создаёшь геттер — метод, 
который будет вызван при чтении значения.

*** Почему не нужно явно писать @вес.getter?

Потому что декоратор @property уже подразумевает создание геттера! 
То есть следующая запись эквивалентна предыдущей:
'''
class МойДомашнийЛюбимец:
    def __init__(self, вес):
        self._вес = вес

    @property
    def вес(self):
        return self._вес

    @вес.getter
    def вес(self):
        return self._вес
'''
Разница лишь в том, что первая форма короче и проще воспринимается. 
Поэтому вторую форму применяют крайне редко, ведь смысл одинаковый.

Подведем итоги:

* @property создает геттер автоматически — его достаточно написать один раз.
* Дополнительный декоратор @имя.getter нужен только в редких случаях, 
    когда ты хочешь переопределить существующий геттер или создать 
    альтернативный вариант чтения данных.
Поэтому обычно пишут просто:
'''
@property
def вес(self):
    return self._вес

'''
КОГДА GETTER НЕОБХОДИМ ???
Когда нужен дополнительный декоратор @имя.getter?

Обычно, если ты используешь стандартный синтаксис @property, 
дополнительного декоратора @имя.getter указывать не требуется. 
Тем не менее, он пригодится в особых ситуациях:

1. Переопределение существующего геттера
    Иногда ты можешь захотеть временно заменить существующую реализацию 
    геттера на другую версию, сохранив оригинальную функциональность. 
    Скажем, допустим, ты хочешь добавить дополнительную логику 
    к процессу чтения какого-то значения.Пример:
'''
# ...разъяснение кода ниже...-->
class Employee:
    def __init__(self, name):
        self._name = name

    @property
    def name(self):
        return self._name

    # Переопределяем геттер временно
    @name.getter
    def name(self):
        return f"*** Секретное имя ***"

emp = Employee("Иван Петров")
print(emp.name)  # Вернет: *** Секретное имя ***
'''
В данном случае оригинальный геттер заменяется новым, 
который возвращает секретное имя.

2. Создание альтернативного варианта чтения данных
    Возможно, у тебя есть ситуация, когда одно и то же свойство 
    доступно в разных формах. Например, обычное чтение значения 
    и дополнительная обработка перед возвратом результата.
    Пример:
'''
class Product:
    def __init__(self, price):
        self._price = price

    @property
    def price(self):
        return self._price

    # Альтернативный геттер для цены с НДС
    @price.getter
    def price_with_tax(self):
        tax_rate = 0.2  # Ставка налога 20%
        return round(self.price * (1 + tax_rate), 2)

product = Product(100)
print(product.price)          # Цена без налогов: 100
print(product.price_with_tax) # Цена с налогом: 120.0
'''
Здесь свойство price сохраняет обычную цену товара, а дополнительное 
свойство price_with_tax рассчитывает стоимость с учётом налога.

КЛЮЧЕВОЕ ПРАВИЛО:
Если ты просто хочешь определить обычный геттер, то 
достаточно обычного синтаксиса:
'''
@property
def имя_свойства(self):
    ...
'''
Только в специфичных случаях, когда нужно временно изменить 
или дополнить поведение геттера, используй 
дополнительный декоратор @имя.getter.
Таким образом, дополнительная декларация @имя.getter 
необходима довольно редко и применяется преимущественно 
в специализированных сценариях, когда стандартного поведения недостаточно.
'''
# -->...разъяснение кода с секретным именем...
'''
Хорошо, давай объясню совсем просто, будто рассказываю ребенку.

Представь, что у тебя есть волшебная коробка, в которой лежит 
настоящее имя человека (например, «Иван Петров»). Эта коробочка 
называется нашим внутренним полем `_name`. 

Теперь наша цель — показать людям либо настоящее имя, 
либо закодированное имя (для безопасности). Но показывать настоящую 
фамилию можно не всегда, например, когда мы работаем 
с конфиденциальной информацией.

## 🧑‍🤝‍🧑 Что происходит в коде?

Сначала мы создаем объект класса `Employee` с именем "Иван Петров":
'''
emp = Employee("Иван Петров")
'''
Далее у нас есть свойство `name`, которое выглядит так:
'''
@property
def name(self):
    return self._name
'''
Это значит, что когда кто-то попросит назвать имя, мы покажем содержимое 
коробки (получим настоящее имя).

Затем идет интересный момент:
'''
@name.getter
def name(self):
    return f"*** Секретное имя ***"
'''
Здесь мы решили временно изменить наше свойство так, чтобы вместо 
настоящего имени показывалось "*** Секретное имя ***". Другими словами, 
мы взяли прежнюю коробку и временно поменяли этикетку — теперь видим 
надпись "*** Секретное имя ***", а не настоящее имя.

Когда мы делаем запрос:
'''
print(emp.name)
'''
Программа смотрит на наш временный геттер и видит надпись 
"*** Секретное имя ***", поэтому печатает именно её.

### Запомним главное:

- Изначально свойство `name` просто показывает настоящее имя.
- Используя дополнительный декоратор `@name.getter`, мы временно 
    изменили поведение и стали показывать секретное имя.

Таким образом, эта техника полезна, если нужно ненадолго изменить 
способ отображения данных, сохраняя основную функциональность неизменной.
'''