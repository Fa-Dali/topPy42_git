'''
Модуль `threading` в Python предоставляет богатый инструментарий для
работы с потоками исполнения (threads). Давайте детально рассмотрим
ключевые классы и методы, предоставляемые этим модулем.
'''

## Модуль `threading`

### Класс `Thread`
'''
Класс `Thread` представляет объект отдельного потока исполнения. 
Его экземпляр запускает отдельный поток, выполняющий некоторую задачу.

#### === 1 === 
Конструктор класса `Thread`:
'''
Thread(group=None,
       target=None,
       name=None,
       args=(),
       kwargs={},
       *,
       daemon=None)
'''
- **group**: Группа потоков, неиспользуется в стандартной библиотеке.
- **target**: Целевая функция, которую нужно исполнить в отдельном потоке.
- **name**: Название потока.
- **args**: Аргументы целевой функции.
- **kwargs**: Именованные аргументы целевой функции.
- **daemon**: Флаг, определяющий демон-поток. Демоны завершаются 
              автоматически, когда прекращается главная программа.

#### === 2 === 
Методы класса `Thread`:

- **start()**: Запускает поток исполнения. 
              Этот метод необходим для начала выполнения потока.
- **run()**: Выполняемая целевая функция. 
              Обычно она реализуется в подклассах, если задача не задаётся 
              аргументом `target`.
- **join(timeout=None)**: Ждёт завершения потока, 
              с возможностью установки тайм-аута.
- **is_alive()**: Возвращает `True`, если поток активен, и 
                            `False`, если завершил исполнение.
- **setDaemon(bool_value)** и **isDaemon()**: Устанавливает и возвращает 
              значение флага демона.
- **getName()** и **setName(new_name)**: Управление названием потока.
- **ident**: Уникальный идентификатор потока.
---

### === 3 === 
Класс `Timer`
Позволяет отложить выполнение некоторой функции на определённое время.

#### Конструктор класса `Timer`:
'''
Timer(interval, function, args=None, kwargs=None)
'''
- **interval**: Время задержки перед выполнением задачи.
- **function**: Функцию, которая будет выполнена после истечения интервала.
- **args**: Позиционные аргументы для исполняемой функции.
- **kwargs**: Именованные аргументы для исполняемой функции.

#### Методы класса `Timer`:
- **start()**: Запускает таймер.
- **cancel()**: Останавливает запущенный таймер, если он ещё не сработал.
---

### === 4 === 
Локальные хранилища потока (`local storage`)
Класс `local` позволяет хранить уникальные данные для каждого потока.

#### Создание локальных данных:
```python
local_storage = threading.local()
```

Затем можно создавать атрибуты для локальной области видимости:
```python
local_storage.my_variable = value
```
==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  
  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  
==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  
---

### Блокировки и примитивы синхронизации

Модуль предлагает ряд механизмов для синхронизации потоков:

=== 5 ===
#### 1. **Lock (Mutex)**
Базовый замок, обеспечивающий взаимоисключающую блокировку ресурсов.

'''
lock = threading.Lock()
lock.acquire()  # Заблокировать ресурс
lock.release()  # Освободить ресурс
'''
=== 6 ===
#### 2. **RLock (Reentrant Lock)**
Рекурсивный замок, позволяющий одному потоку многократно захватывать замок.

'''
rlock = threading.RLock()
rlock.acquire()  # Захват ресурса
rlock.release()  # Освобождение ресурса
'''
=== 7 ===
#### 3. **Semaphore**
Семафоры позволяют ограничить количество потоков, имеющих доступ к ресурсу.

'''
semaphore = threading.Semaphore(value=2)  # Максимальное количество потоков - 2
semaphore.acquire()  # Попытка захвата семафора
semaphore.release()  # Освобождение семафора
'''
=== 8 ===
#### 4. **Condition**
Условные переменные обеспечивают синхронизацию между потоками на основе сигналов и ожиданий.

'''
condition = threading.Condition(lock=None)
condition.wait()      # Ждать сигнала
condition.notify()    # Сигналить одному потоку
condition.notify_all() # Сигналить всем ожидающим потокам
'''
=== 9 ===
#### 5. **Event**
События помогают координировать потоки на основе флагов.

'''
event = threading.Event()
event.wait()          # Ждать наступления события
event.set()           # Установить событие
event.clear()         # Сбросить событие
event.is_set()        # Проверить, установлено ли событие
'''
=== 10 ===
#### 6. **Barrier**
Барьер служит точкой встречи для множества потоков.

'''
barrier = threading.Barrier(parties=3)
barrier.wait()        # Ждать, пока все потоки достигнут барьера
'''

---
### Примеры практического использования

Пример с использованием блокировки:
'''
import threading

shared_resource = 0
lock = threading.Lock()

def increment():
    global shared_resource
    lock.acquire()
    shared_resource += 1
    lock.release()

for i in range(10):
    threading.Thread(target=increment).start()
'''

Пример с условием:
'''
import threading

condition = threading.Condition()
resource_available = False

def producer():
    global resource_available
    condition.acquire()
    resource_available = True
    condition.notify()
    condition.release()

def consumer():
    global resource_available
    condition.acquire()
    while not resource_available:
        condition.wait()
    print("Ресурс доступен!")
    condition.release()

producer_thread = threading.Thread(target=producer)
consumer_thread = threading.Thread(target=consumer)

producer_thread.start()
consumer_thread.start()
'''

---
### Резюме

Модуль `threading` предоставляет мощные средства для работы с параллельными 
потоками, включая создание потоков, примитивы синхронизации и локальную 
область видимости данных. Правильно применяя представленные инструменты, 
можно решать разнообразные задачи многопоточного программирования на Python.
'''