'''
Модуль `threading` в Python позволяет создавать многопоточные
программы, используя потоки исполнения (`threads`), что обеспечивает
параллельное выполнение различных частей приложения. Давайте подробно
рассмотрим ключевые аспекты модуля `threading`.

### Основные компоненты

#### 1. **Thread**
Класс `Thread`, представляющий собой поток исполнения. Создается
экземпляр класса Thread, передавая целевую функцию потока через
аргумент `target`. Основной метод — запуск потока через `.start()`.

'''
import threading

def worker():
    print("Worker thread started")

thread = threading.Thread(target=worker)
thread.start()
'''

#### 2. **Lock** и **RLock**
Механизмы синхронизации потоков. Позволяют предотвратить одновременный 
доступ нескольких потоков к одному ресурсу (например, переменной), 
обеспечивая последовательное выполнение операций.

- **Lock**: простой блокировщик, допускающий захват блокировки одним 
потоком один раз.
- **RLock**: рекурсивная блокировка, позволяющая потоку многократно 
захватить одну и ту же блокировку.

Пример использования Lock:
'''
lock = threading.Lock()

def critical_section():
    with lock:
        # Критическая секция
        pass
'''

#### 3. **Semaphore**, **Event**, **Condition**
Дополнительные механизмы управления потоками:

- **Semaphore**: ограничивает количество одновременно выполняемых потоков.
- **Event**: сигнализирует другим потокам о событии (ожидают сигнал).
- **Condition**: используется совместно с блокировкой для ожидания 
изменения состояния ресурса.

Пример семафора:
'''
semaphore = threading.Semaphore(value=2)

def task():
    semaphore.acquire()
    try:
        # Выполняемая задача
        pass
    finally:
        semaphore.release()
'''

#### 4. **Timer**
Позволяет запустить поток с задержкой через заданное время.
'''
timer = threading.Timer(interval=5, function=worker)
timer.start()
'''

---
### Важные моменты при работе с потоками
1. **Проблема гонки (race condition)**:
   Когда два или больше потоков пытаются изменить общую переменную 
   одновременно, это приводит к неопределенности результата. Чтобы 
   избежать проблемы, используются блокировки.

2. **Deadlock** («мертвая блокировка») возникает, когда два потока 
    взаимно ожидают освобождения ресурсов друг друга, создавая 
    тупиковую ситуацию.

3. **Global Interpreter Lock (GIL)**:
   Ограничение Python, связанное с работой интерпретатора CPython. 
   Несмотря на многопоточность, реально параллельная обработка возможна 
   лишь при операциях ввода-вывода (I/O bound). Вычисления CPU-bound 
   будут выполняться последовательно благодаря GIL.

---
### Примеры использования
#### Пример с несколькими потоками и блокировкой:
'''
import threading

shared_resource = []
lock = threading.Lock()

def add_to_list(item):
    global shared_resource
    with lock:
        shared_resource.append(item)

threads = [
    threading.Thread(target=add_to_list, args=(i,))
    for i in range(10)
]
for t in threads:
    t.start()
for t in threads:
    t.join()
print(shared_resource)
'''

Этот пример демонстрирует использование блокировки для защиты общей 
структуры данных.

---

### Заключение

Многопоточность в Python является мощным инструментом повышения 
производительности приложений, особенно тех, где важна 
параллельность I/O операций. Однако важно помнить о проблемах 
безопасности и особенностях реализации, связанных 
с Global Interpreter Lock.

======================================================================
МОДУЛЬ threading
    Методы:
=== 1 ===
    threading.activeCount() - возвращает количество активных объектов 
                                потока
=== 2 ===
    threading.currentThread() - возвращает количество объектов потока в
                                элементе управления потоком вызывающего 
                                объекта
=== 3 ===
    threading.enumerate() - возвращает список всех активных в данный момент
                            объектов потока
=======================================================================
=======================================================================
класс Thread:
=== 4 === run() - является точкой входа для потока

=== 5 === start() - запускает поток, вызывая метод run()

=== 6 === join([время]) - ожидает завершения потока

=== 7 === isAlive() - проверяет, выполняется ли поток

=== 8 === getName() - возвращает имя потока

=== 9 === setName() - устанавливает имя потока


'''