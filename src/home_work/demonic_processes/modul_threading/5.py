'''
Продолжим изучение класса `Thread` и поговорим о ключевом методе `start()`.

### Метод `start()`

Метод `start()` предназначен для начала выполнения потока. Его главная
роль заключается в инициализации новой нити выполнения, после чего
вызывается внутренний метод `run()`, содержащий логику самого потока.

#### Особенности метода `start()`:
- Вызывая `start()`, мы даем команду операционной системе создать
    новый поток и начать его выполнение.
- Внутри этого потока первым вызывается метод `run()`, где реализована
    вся логика потока.
- Нельзя вызывать метод `start()` дважды для одного и того же потока,
    иначе возникнет исключение.

### Пример использования метода `start()`

Посмотрим, как выглядит простейший пример использования метода `start()`
для запуска потоков:

'''
import threading
import time

class WorkerThread(threading.Thread):
    def __init__(self, name):
        super().__init__()
        self.name = name

    def run(self):
        print(f"Поток {self.name} стартовал.")
        time.sleep(2)  # Пауза для демонстрации асинхронности
        print(f"Поток {self.name} завершил работу.")

# Создаем и запускаем потоки
thread1 = WorkerThread("Рабочий поток 1")
thread2 = WorkerThread("Рабочий поток 2")

# Запускаем оба потока
thread1.start()
thread2.start()

# Ожидаем завершения обоих потоков
thread1.join()
thread2.join()

print("Все потоки завершены.")
'''

### Разбор деталей:

- Мы создали подкласс `WorkerThread`, унаследованный от класса `Thread`.
- Переопределили метод `run()`, который будет содержать логику нашего 
    потока (простые операции печати сообщений и небольшая пауза).
- При создании объектов потоков мы присваиваем каждому уникальный 
    идентификатор (`name`) для удобства идентификации.
- Далее вызываем метод `start()` для старта каждого потока. Только после 
    вызова `start()` поток начнет свое выполнение, 
    вызвав внутренний метод `run()`.

### Важно запомнить:
- Метод `start()` непосредственно запускает поток, выполняя весь 
    дальнейший код внутри метода `run()`.
- Попытка повторного вызова `start()` приведет к ошибке.
- Всегда рекомендуется ожидать завершения всех созданных потоков, 
    используя метод `join()`, чтобы гарантировать правильное завершение 
    работы программы.

Таким образом, метод `start()` необходим для инициации выполнения 
потоков и передачи управления внутреннему методу `run()`, содержащему 
главную логику потока.

======================================================================

Давайте попробуем объяснить метод `start()` ещё раз немного подробнее и 
нагляднее.

### Повторим основное:
- Методы `run()` и `start()` тесно связаны между собой, 
    но служат разным целям.
- Метод `run()` — это то место, куда записывают логику, которую 
    поток будет выполнять.
- Но сам по себе метод `run()` не начинает выполнение потока. 
    Для этого нужен метод `start()`.

### Суть метода `start()`
Метод `start()` — это специальная команда, которая приказывает 
операционной системе создать новый поток и запустить его. Когда ОС 
запускает поток, она автоматически вызывает метод `run()`, в котором 
программист указал нужную логику.

### Ключевое отличие:
- **`run()`** — это метод, в котором указывается, 
                ЧТО поток будет делать (логика).
- **`start()`** — это метод, которым запускается ПОТОК, 
                начинающий выполнение указанной логики.

### Пример наглядно поясняет это:
'''
import threading
import time

class MyThread(threading.Thread):
    def __init__(self, message):
        super().__init__()
        self.message = message

    def run(self):
        """
        Здесь прописана логика, которая будет исполняться в новом потоке.
        Она запускается автоматически после вызова start().
        """
        print(f"Началась работа потока: {self.message}")
        time.sleep(2)  # Сделаем небольшую паузу
        print(f"Работа потока завершена: {self.message}")

# Создали поток, но он пока неактивен
my_thread = MyThread("Тестовый поток")

# Сейчас никакой работы не выполняется
print("До вызова start(): ", my_thread.is_alive())  # Вернет False

# Вызываем start(), ОС создаст новый поток и начнёт его выполнение
my_thread.start()

# Теперь поток запущен
print("После вызова start(): ", my_thread.is_alive())  # Вернёт True

# Ждём завершения потока
my_thread.join()

print("Программа завершилась.")
'''

### Пояснения к примеру:

1. **Создание потока**: мы объявили объект класса `MyThread`, 
                        но сам поток ещё не работает.
2. **`is_alive()`**: метод показывает, запущен ли поток. 
                        До вызова `start()` значение вернётся как `False`.
3. **`start()`**: запускает поток, операционная система создаёт новую 
                    нить выполнения и автоматически вызывает метод `run()`, 
                    указанный нами ранее.
4. **`join()`**: гарантирует, что главный поток дождетется завершения 
                    дочернего потока перед завершением программы.

### Почему нельзя вызвать `run()` вручную?
Самостоятельный вызов метода `run()` возможен, но это неправильно и 
бессмысленно. Дело в том, что таким образом не создастся настоящий 
поток, а просто выполнится обычная функция синхронно в главном потоке. 
Поэтому правильный способ — всегда пользоваться методом `start()`, 
который запускает реальный поток.

### Итог:
- Метод `start()` — запускает новый поток, создавая отдельную линию выполнения.
- Вызванный поток автоматически выполняет метод `run()`, в котором 
    написана нужная логика.
- Без вызова `start()` поток не заработает.
'''